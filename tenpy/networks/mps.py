r"""This module contains a base class for a Matrix Product State (MPS).

An MPS looks roughly like this::

    |   -- B[0] -- B[1] -- B[2] -- ...
    |       |       |      |

We use the following label convention for the `B` (where arrows indicate `qconj`)::

    |  vL ->- B ->- vR
    |         |
    |         ^
    |         p

We store one 3-leg tensor `_B[i]` with labels ``'vL', 'vR', 'p'`` for each of the `L` sites
``0 <= i < L``.
Additionally, we store ``L+1`` singular value arrays `_S[ib]` on each bond ``0 <= ib <= L``,
independent of the boundary conditions.
``_S[ib]`` gives the singular values on the bond ``i-1, i``.
However, be aware that e.g. :attr:`~tenpy.networks.mps.MPS.chi` returns only the dimensions of the
:attr:`~tenpy.networks.mps.MPS.nontrivial_bonds` depending on the boundary conditions.

The matrices and singular values always represent a normalized state
(i.e. ``np.linalg.norm(psi._S[ib]) == 1`` up to roundoff errors),
but (for finite MPS) we keep track of the norm in :attr:`~tenpy.networks.mps.MPS.norm`
(which is respected by :meth:`~tenpy.networks.mps.MPS.overlap`, ...).

Valid MPS boundary conditions (not to confuse with `bc_coupling` of
:class:`tenpy.models.model.CouplingModel`)  are the following:

==========  ===================================================================================
`bc`        description
==========  ===================================================================================
'finite'    Finite MPS, ``G0 s1 G1 ... s{L-1} G{l-1}``. This is achieved
            by using a trivial left and right bond ``s[0] = s[-1] = np.array([1.])``.
'segment'   Generalization of 'finite', describes an MPS embedded in left and right
            environments. The left environment is described by ``chi[0]`` *orthonormal* states
            which are weighted by the singular values ``s[0]``. Similar, ``s[L]`` weight some
            right orthonormal states. You can think of the left and right states to be
            generated by additional MPS, such that the overall structure is something like
            ``... s L s L [s0 G0 s1 G1 ... s{L-1} G{L-1} s{L}] R s R s R ...``
            (where we save the part in the brackets ``[ ... ]`` ).
            Currently, this is only implemented for DMRG.
            Relevant papers for time evolution: :cite:`phien2012`, :cite:`phien2013`,
            :cite:`milsted2013`, and :cite:`zauner2015`.
'infinite'  infinite MPS (iMPS): we save a 'MPS unit cell' ``[s0 G0 s1 G1 ... s{L-1} G{L-1}]``
            which is repeated periodically, identifying all indices modulo ``self.L``.
            In particular, the last bond ``L`` is identified with ``0``.
            (The MPS unit cell can differ from a lattice unit cell).
            bond is identified with the first one.
==========  ===================================================================================

An MPS can be in different 'canonical forms' (see :cite:`vidal2004,schollwoeck2011`).
To take care of the different canonical forms, algorithms should use functions like
:meth:`~tenpy.networks.mps.MPS.get_theta`, :meth:`~tenpy.networks.mps.MPS.get_B`
and :meth:`~tenpy.networks.mps.MPS.set_B` instead of accessing them directly,
as they return the `B` in the desired form (which can be chosen as an argument).
The values of the tuples for the form correspond to the exponent of the singular values
on the left and right.
To keep track of a "mixed" canonical form ``A A A s B B``, we save the tuples for each
site of the MPS in :attr:`MPS.form`.

======== ========== ==========================================================================
`form`   tuple      description
======== ========== ==========================================================================
``'B'``  (0, 1)     right canonical: ``_B[i] = -- Gamma[i] -- s[i+1]--``
                    The default form, which algorithms assume.
``'C'``  (0.5, 0.5) symmetric form: ``_B[i] = -- s[i]**0.5 -- Gamma[i] -- s[i+1]**0.5--``
``'A'``  (1, 0)     left canonical: ``_B[i] = -- s[i] -- Gamma[i] --``.
``'G'``  (0, 0)     Save only ``_B[i] = -- Gamma[i] --``.
``'Th'`` (1, 1)     Form of a local wave function `theta` with singular value on both sides.
                    ``psi.get_B(i, 'Th') is equivalent to ``psi.get_theta(i, n=1)``.
``None`` ``None``   General non-canonical form.
                    Valid form for initialization, but you need to call
                    :meth:`~tenpy.networks.mps.MPS.canonical_form` (or similar)
                    before using algorithms.
======== ========== ==========================================================================

.. _iMPSWarning:

A warning about infinite MPS
----------------------------
Infinite MPS by definition have a the unit cell repeating indefinitely.
This makes a few things tricky. See :cite:`vanderstraeten2019` for a very good review, here
we only discuss the biggest pitfalls.

Consider a (properly normalized) iMPS representing some state :math:`\ket{\psi}`.
If we make a copy and change just one number of the MPS by some small :math:`\epsilon`,
we get a new iMPS wave function :math:`\ket{\phi}`. Clearly, this is "almost" the same state.
Indeed, if we construct the :class:`TransferMatrix` between :math:`\phi` and :math:`\psi` and
check the eigenvalues, we will find a dominant eigenvalue :math:`\eta \approx 1`
up to an error depending on :math:`\epsilon`.
However, since it is not quite 1, the formal overlap between the iMPS vanishes
in the thermodynamic limit :math:`N \rightarrow \infty`,

.. math ::

    \langle \phi | \psi \rangle = \lim_{N \rightarrow \infty} (\mathrm{TransferMatrix})^N
    = \lim_{N \rightarrow \infty} \eta^N \ =0.

Since this formal overlap is always 0 (for normalized, different iMPS with :math:`\eta < 1`),
1 (for normalized equal iMPS with :math:`\eta=1`),
or infinite (for non-normalized iMPS with :math:`\eta > 1`),
we rather define the :meth:`MPS.overlap` to return directly the dominant eigenvalue :math:`\eta`
of the transfer matrix for infinite MPS, which is a more sensible measure for how close two iMPS
are.

.. warning ::

    For infinite MPS methods like :meth:`MPS.overlap`, :meth:`apply` and :meth:`MPS.apply_local`
    might not do what you naively expect.
    As a trivial consequence, you can not apply a (local or infinite) operator to
    an iMPS, calculate the overlap and expect to get the same as if you calculate
    the expectation value of that operator!

In fact, there are more issues in this naive approach, hidden in the "apply an operator".
How the "apply" has to work internally, depends crucially on the form of the operator.
First, you can can have a *single local operator*, e.g. a single :math:`S^z_i`.
Applying such an operator breaks translation invariance,
so you can not write the result as iMPS. (Rather, you would need to consider a different unit
cell in a background of an iMPS, which we define as "segment" boundary conditions.)

Second, you might have an extensive "sum of local operators",
e.g. :math:`M = \sum_i S^z_i` or directly the Hamiltonian.
Again, the local terms break translation invariance. While in this case the sum can recover the
translation invariance, the result is again not an iMPS, but in the tangent space of iMPS
(or a generalization thereof if the local terms have more than one site).
Expectation values, e.g. the energy, are extensive sums of some density (which is returned
when you calculate the expectation values).
You can not get this from :meth:`MPS.overlap`, since the latter gives products of local values
rather than sums.
In general, you might even have higher moments (e.g., :math:`M^2` or :math:`H^2`), for which
expectation values scale not just linear in :math:`N`, but as higher-order polynomials.

Finally, you can have a product of local operators rather than a sum (roughly speaking, ignoring
the issue of commutation relations for a second).
An example would be a time evolution operator, say Trotter decomposed as

.. math ::
    U = exp(-i H t) \approx \prod_{i~\mathrm{even}} e^{-i h_i t}
                            \prod_{i~\mathrm{odd}} e^{-i h_i t}.

After applying such an evolution operator, you indeed stay in the form of a translation invariant
iMPS, so this is the form *assumed* when calling MPO :meth:`~tenpy.networks.mpo.MPO.apply` on an
MPS.
"""
# Copyright (C) TeNPy Developers, GNU GPLv3

from abc import ABCMeta, abstractmethod
import numpy as np
import warnings
import random
import copy
from collections.abc import Iterable
import logging

logger = logging.getLogger(__name__)

from ..linalg import np_conserved as npc
from ..linalg import sparse
from ..linalg.krylov_based import Arnoldi
from .site import group_sites
from ..tools.misc import argsort, to_iterable, to_array, get_recursive, inverse_permutation
from ..tools.math import lcm, entropy
from ..tools.params import asConfig
from ..tools.cache import DictCache
from ..tools import hdf5_io
from ..algorithms.truncation import TruncationError, svd_theta, _machine_prec_trunc_par
from ..algorithms.tebd import RandomUnitaryEvolution

__all__ = ['BaseMPSExpectationValue', 'MPS', 'BaseEnvironment', 'MPSEnvironment', 'TransferMatrix',
           'InitialStateBuilder', 'build_initial_state']


class BaseMPSExpectationValue(metaclass=ABCMeta):
    r"""Base class providing unified expectation value framework for MPS and MPSEnvironment.

    For general expectation values of operators 'ops' between different states
    ``<bra|ops|ket>`` we need to include the left/ right environments ``LP`` and ``RP``.
    These are calculated in :class:`MPSEnvironment`.
    For "standard" expectation values ``<psi|ops|psi>``, the environments are trivial identities
    due to the canonical from.

    Subclasses need to have the attributes `sites`, `L`, `bc`, `finite`.
    See :class:`MPS` for details.
    """

    def expectation_value(self, ops, sites=None, axes=None):
        """Expectation value ``<bra|ops|ket>`` of (n-site) operator(s).

        Calculates n-site expectation values of operators sandwiched between bra and ket.
        For examples the contraction for a two-site operator on site `i` would look like::

            |          .--S--B[i]--B[i+1]--.
            |          |     |     |       |
            |          |     |-----|       |
            |          LP[i] | op  |       RP[i+1]
            |          |     |-----|       |
            |          |     |     |       |
            |          .--S--B*[i]-B*[i+1]-.

        Here, the `B` are taken from `ket`, the `B*` from `bra`.
        For MPS expectation values these are the same and LP/ RP are trivial.


        Parameters
        ----------
        ops : (list of) { :class:`~tenpy.linalg.np_conserved.Array` | str }
            The operators, for which the expectation value should be taken,
            All operators should all have the same number of legs (namely `2 n`).
            If less than ``len(sites)`` operators are given, we repeat them periodically.
            Strings (like ``'Id', 'Sz'``) are translated into single-site operators defined by
            :attr:`sites`.
        sites : list
            List of site indices. Expectation values are evaluated there.
            If ``None`` (default), the entire chain is taken (clipping for finite b.c.)
        axes : None | (list of str, list of str)
            Two lists of each `n` leg labels giving the physical legs of the operator used for
            contraction. The first `n` legs are contracted with conjugated `B`,
            the second `n` legs with the non-conjugated `B`.
            ``None`` defaults to ``(['p'], ['p*'])`` for single site (n=1), or
            ``(['p0', 'p1', ... 'p{n-1}'], ['p0*', 'p1*', .... 'p{n-1}*'])`` for `n` > 1.

        Returns
        -------
        exp_vals : 1D ndarray
            Expectation values, ``exp_vals[i] = <bra|ops[i]|ket>``, where ``ops[i]`` acts on
            site(s) ``j, j+1, ..., j+{n-1}`` with ``j=sites[i]``.

            .. warning ::

                The :class:`MPSEnvironment` variant of this method takes the accumulated MPS
                :attr:`~tenpy.networks.mps.MPS.norm` into account, which is non-trivial e.g. when you
                used `apply_local_op` with non-unitary operators.

                In contrast, the :class:`MPS` variant of this method *ignores* the `norm`,
                i.e. returns the expectation value for the normalized state.

        Examples
        --------
        Let's prepare a state in alternating ``|+z>, |+x>`` states:

        .. doctest :: MPS.expectation_value

            >>> spin_half = tenpy.networks.site.SpinHalfSite(conserve=None)
            >>> p_state = ['up', [np.sqrt(0.5), -np.sqrt(0.5)]]*3
            >>> psi = tenpy.networks.mps.MPS.from_product_state([spin_half]*6, p_state)

        One site examples (n=1):

        .. doctest :: MPS.expectation_value

            >>> Sz = psi.expectation_value('Sz')
            >>> print(Sz)
            [0.5 0.  0.5 0.  0.5 0. ]
            >>> Sx = psi.expectation_value('Sx')
            >>> print(Sx)
            [ 0.  -0.5  0.  -0.5  0.  -0.5]
            >>> print(psi.expectation_value(['Sz', 'Sx']))
            [ 0.5 -0.5  0.5 -0.5  0.5 -0.5]
            >>> print(psi.expectation_value('Sz', sites=[0, 3, 4]))
            [0.5 0.  0.5]

        Two site example (n=2), assuming homogeneous sites:

        .. doctest :: MPS.expectation_value

            >>> SzSx = npc.outer(psi.sites[0].Sz.replace_labels(['p', 'p*'], ['p0', 'p0*']),
            ...                  psi.sites[1].Sx.replace_labels(['p', 'p*'], ['p1', 'p1*']))
            >>> print(psi.expectation_value(SzSx))  # note: len L-1 for finite bc, or L for infinite
            [-0.25  0.   -0.25  0.   -0.25]

        Example measuring <psi|SzSx|psi> on each second site, for inhomogeneous sites:

        .. doctest :: MPS.expectation_value

            >>> SzSx_list = [npc.outer(psi.sites[i].Sz.replace_labels(['p', 'p*'], ['p0', 'p0*']),
            ...                        psi.sites[i+1].Sx.replace_labels(['p', 'p*'], ['p1', 'p1*']))
            ...              for i in range(0, psi.L-1, 2)]
            >>> print(psi.expectation_value(SzSx_list, range(0, psi.L-1, 2)))
            [-0.25 -0.25 -0.25]

        Expectation value with different bra and ket in an MPSEnvironment:

        .. doctest :: MPS.expectation_value

            >>> spin_half = tenpy.networks.site.SpinHalfSite(conserve=None)
            >>> p2_state = [[np.sqrt(0.5), -np.sqrt(0.5)], 'up']*3
            >>> phi = tenpy.networks.mps.MPS.from_product_state([spin_half]*6, p2_state)
            >>> env = tenpy.networks.mps.MPSEnvironment(phi, psi)
            >>> Sz = env.expectation_value('Sz')
            >>> print(Sz)
            [0.0625 0.0625 0.0625 0.0625 0.0625 0.0625]

        """
        ops, sites, n, (op_ax_p, op_ax_pstar) = self._expectation_value_args(ops, sites, axes)
        ax_p = ['p' + str(k) for k in range(n)]
        ax_pstar = ['p' + str(k) + '*' for k in range(n)]
        bra, ket = self._get_bra_ket()
        E = []
        for i in sites:
            op, needs_JW = self.get_op(ops, i)
            op = op.replace_labels(op_ax_p + op_ax_pstar, ax_p + ax_pstar)
            theta_ket = ket.get_theta(i, n)
            if needs_JW:
                if isinstance(self, MPSEnvironment):
                    self.apply_JW_string_left_of_virt_leg(theta_ket, 'vL', i)
                else:
                    msg = "Expectation value of operator that needs JW string can't work"
                    raise ValueError(msg)
            C = npc.tensordot(op, theta_ket, axes=[ax_pstar, ax_p])  # C has same labels as theta
            C = self._contract_with_LP(C, i)  # axes_p + (vR*, vR)
            C = self._contract_with_RP(C, i + n - 1)  # axes_p + (vR*, vL*)
            C.ireplace_labels(['vR*', 'vL*'], ['vL', 'vR'])  # back to original theta labels
            theta_bra = bra.get_theta(i, n)
            E.append(npc.inner(theta_bra, C, axes='labels', do_conj=True))
        return self._normalize_exp_val(E)

    def apply_JW_string_left_of_virt_leg(self, theta, virt_leg_index, i):
        """Apply signs on a virtual MPS leg equivalent to a Jordan-Wigner string on the left.

        If we conserve the (parity of the) total fermion particle number, each Schmidt state
        ``|alpha>`` on a given bond (here left of site `i`) has a well-defined fermion parity
        number, so we can simply transform ``|alpha> --> (-1)**parity[alpha] |alpha>``.
        The corresponding signs ``(-1)**parity[alpha]`` are extracted by
        :meth:`~tenpy.networks.site.Site.charge_to_JW_signs`.

        .. warning ::

            We may loose an overall, global minus sign in the case that some `B` tensors have
            non-trivial `qtotal`!

        Parameters
        ----------
        theta : :class:`~tenpy.linalg.np_conserved.Array`
            Tensor with virtual leg
        virtual_leg_index : int | str
            Index of the virtual leg on the left of which we want to apply the JW string.
        i : int
            Site index of `theta`.
        """
        # theta can be any form A / B / theta
        leg = theta.get_leg(virt_leg_index)
        charges = leg.to_qflat() #  note: sign doesn't matter since -x % 2 == x % 2
        JW_signs = self.sites[self._to_valid_index(i)].charge_to_JW_signs(charges)
        theta.iscale_axis(JW_signs, virt_leg_index)

    def expectation_value_multi_sites(self, operators, i0):
        r"""Expectation value  ``<bra|op0_{i0}op1_{i0+1}...opN_{i0+N}|ket>``.

        Calculates the expectation value of a tensor product of single-site operators
        acting on different sites next to each other.
        In other words, evaluate the expectation value of a term
        ``op0_i0 op1_{i0+1} op2_{i0+2} ...``, looking like this (with `op` short for `operators`,
        for ``len(operators)=3``)::

            |          .--S--B[i0]---B[i0+1]--B[i0+2]--B[i0+3]--.
            |          |     |       |        |        |        |
            |         LP[i0] op[0]   op[1]    op[2]    op[3]    RP[i0+3]
            |          |     |       |        |        |        |
            |          .--S--B*[i0]--B*[i0+1]-B*[i0+2]-B*[i0+3]-.


        .. warning ::
            This function does *not* automatically add Jordan-Wigner strings!
            For correct handling of fermions, use :meth:`expectation_value_term` instead.

        Parameters
        ----------
        operators : List of { :class:`~tenpy.linalg.np_conserved.Array` | str }
            List of one-site operators. This method calculates the
            expectation value of the n-sites operator given by their tensor
            product.
        i0 : int
            The left most index on which an operator acts, i.e.,
            ``operators[i]`` acts on site ``i + i0``.

        Returns
        -------
        exp_val : float/complex
            The expectation value of the tensorproduct of the given onsite operators,
            ``<bra|operators[0]_{i0} operators[1]_{i0+1} ... |ket>``.

            .. warning ::

                The :class:`MPSEnvironment` variant of this method takes the accumulated MPS
                :attr:`~tenpy.networks.mps.MPS.norm` into account, which is non-trivial e.g. when you
                used `apply_local_op` with non-unitary operators.

                In contrast, the :class:`MPS` variant of this method *ignores* the `norm`,
                i.e. returns the expectation value for the normalized state.
        """
        C = self._corr_ops_LP(operators, i0)
        C = self._contract_with_RP(C, i0 + len(operators) - 1)
        exp_val = npc.trace(C, 'vR*', 'vL*')
        return self._normalize_exp_val(exp_val)

    def correlation_function(self,
                             ops1,
                             ops2,
                             sites1=None,
                             sites2=None,
                             opstr=None,
                             str_on_first=True,
                             hermitian=False,
                             autoJW=True):
        r"""Correlation function  ``<bra|op1_i op2_j|ket>`` of single site operators,
        sandwiched between bra and ket.
        For examples the contraction for a two-site operator on site `i` would look like::

            |          .--S--B[i]--B[i+1]--...--B[j]---.
            |          |     |     |            |      |
            |          |     |     |            op2    |
            |          LP[i] |     |            |      RP[j]
            |          |     op1   |            |      |
            |          |     |     |            |      |
            |          .--S--B*[i]-B*[i+1]-...--B*[j]--.


        Onsite terms are taken in the order ``<psi | op1 op2 | psi>``.
        If `opstr` is given and ``str_on_first=True``, it calculates::

            |           for i < j                               for i > j
            |
            |          .--S--B[i]---B[i+1]--...- B[j]---.     .--S--B[j]---B[j+1]--...- B[i]---.
            |          |     |      |            |      |     |     |      |            |      |
            |          |     opstr  opstr        op2    |     |     op2    |            |      |
            |          LP[i] |      |            |      RP[j] LP[j] |      |            |      RP[i]
            |          |     op1    |            |      |     |     opstr  opstr        op1    |
            |          |     |      |            |      |     |     |      |            |      |
            |          .--S--B*[i]--B*[i+1]-...- B*[j]--.     .--S--B*[j]--B*[j+1]-...- B*[i]--.


        For ``i==j``, no `opstr` is included.
        For ``str_on_first=False``, the `opstr` on site ``min(i, j)`` is always left out.
        Strings (like ``'Id', 'Sz'``) in the arguments are translated into single-site
        operators defined by the :class:`~tenpy.networks.site.Site` on which they act.
        Each operator should have the two legs ``'p', 'p*'``.

        .. warning ::
            This function is only evaluating correlation functions by moving right, and hence
            can be inefficient if you try to vary the left end while fixing the right end.
            In that case, you might be better off (=faster evaluation) by using
            :meth:`term_correlation_function_left` with a small for loop over the right indices.

        Parameters
        ----------
        ops1 : (list of) { :class:`~tenpy.linalg.np_conserved.Array` | str }
            First operator of the correlation function (acting after ops2).
            If a list is given, ``ops1[i]`` acts on site `i` of the MPS.
            Note that even if a list is given, we still just evaluate two-site correlations!
            ``psi.correlation_function(['A','B'], ['C', 'D'])`` evaluates
            ``<A_i C_j>`` for even i and even j, ``<B_i C_j>`` for even i and odd j,
            ``<B_i C_j>`` for odd i and even j, and ``<B_i D_j>`` for odd i and odd j.
        ops2 : (list of) { :class:`~tenpy.linalg.np_conserved.Array` | str }
            Second operator of the correlation function (acting before ops1).
            If a list is given, ``ops2[j]`` acts on site `j` of the MPS.
        sites1 : None | int | list of int
            List of site indices `i`; a single `int` is translated to ``range(0, sites1)``.
            ``None`` defaults to all sites ``range(0, L)``.
            Is sorted before use, i.e. the order is ignored.
        sites2 : None | int | list of int
            List of site indices; a single `int` is translated to ``range(0, sites2)``.
            ``None`` defaults to all sites ``range(0, L)``.
            Is sorted before use, i.e. the order is ignored.
        opstr : None | (list of) { :class:`~tenpy.linalg.np_conserved.Array` | str }
            Ignored by default (``None``).
            Operator(s) to be inserted between ``ops1`` and ``ops2``.
            If less than :attr:`L` operators are given, we repeat them periodically.
            If given as a list, ``opstr[r]`` is inserted at site `r` (independent of `sites1` and
            `sites2`).
        str_on_first : bool
            Whether the `opstr` is included on the site ``min(i, j)``.
            Note the order, which is chosen that way to handle fermionic Jordan-Wigner strings
            correctly. (In other words: choose ``str_on_first=True`` for fermions!)
        hermitian : bool
            Optimization flag: if ``sites1 == sites2`` and ``Ops1[i]^\dagger == Ops2[i]``
            (which is not checked explicitly!), the resulting ``C[x, y]`` will be hermitian.
            We can use that to avoid calculations, so ``hermitian=True`` will run faster.
        autoJW : bool
            *Ignored* if `opstr` is given.
            If `True`, auto-determine if a Jordan-Wigner string is needed.
            Works only if exclusively strings were used for `op1` and `op2`.

        Returns
        -------
        C : 2D ndarray
            The correlation function ``C[x, y] = <bra|ops1[i] ops2[j]|ket>``,
            where ``ops1[i]`` acts on site ``i=sites1[x]`` and ``ops2[j]`` on site ``j=sites2[y]``.
            If `opstr` is given, it gives (for ``str_on_first=True``):
            - For ``i < j``: ``C[x, y] = <bra|ops1[i] prod_{i <= r < j} opstr[r] ops2[j]|ket>``.
            - For ``i > j``: ``C[x, y] = <bra|prod_{j <= r < i} opstr[r] ops1[i] ops2[j]|ket>``.
            - For ``i = j``: ``C[x, y] = <bra|ops1[i] ops2[j]|ket>``.
            The condition ``<= r`` is replaced by a strict ``< r``, if ``str_on_first=False``.

            .. warning ::

                The :class:`MPSEnvironment` variant of this method takes the accumulated MPS
                :attr:`~tenpy.networks.mps.MPS.norm` into account, which is non-trivial e.g. when you
                used `apply_local_op` with non-unitary operators.

                In contrast, the :class:`MPS` variant of this method *ignores* the `norm`,
                i.e. returns the expectation value for the normalized state.

        Examples
        --------
        Let's prepare a state in alternating ``|+z>, |+x>`` states:

        .. doctest :: MPS.correlation_function

            >>> spin_half = tenpy.networks.site.SpinHalfSite(conserve=None)
            >>> p_state = ['up', [np.sqrt(0.5), -np.sqrt(0.5)]]*3
            >>> psi = tenpy.networks.mps.MPS.from_product_state([spin_half]*6, p_state, "infinite")

        Default arguments calculate correlations for all `i` and `j` within the MPS unit cell.
        To evaluate the correlation function for a single `i`, you can use ``sites1=[i]``.
        Alternatively, you can use :meth:`term_correlation_function_right`
        (or :meth:`term_correlation_function_left`):

        .. doctest :: MPS.correlation_function

            >>> psi.correlation_function("Sz", "Sx")  # doctest: +SKIP
            array([[ 0.  , -0.25,  0.  , -0.25,  0.  , -0.25],
                   [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ],
                   [ 0.  , -0.25,  0.  , -0.25,  0.  , -0.25],
                   [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ],
                   [ 0.  , -0.25,  0.  , -0.25,  0.  , -0.25],
                   [ 0.  ,  0.  ,  0.  ,  0.  ,  0.  ,  0.  ]])
            >>> psi.correlation_function("Sz", "Sx", [0])
            array([[ 0.  , -0.25,  0.  , -0.25,  0.  , -0.25]])
            >>> corr1 = psi.correlation_function("Sz", "Sx", [0], range(1, 10))
            >>> corr2 = psi.term_correlation_function_right([("Sz", 0)], [("Sx", 0)], 0, range(1, 10))
            >>> assert np.all(np.abs(corr2 - corr1) < 1.e-12)

        For fermions, it auto-determines that/whether a Jordan Wigner string is needed:

        .. doctest :: MPS.correlation_function

            >>> fermion = tenpy.networks.site.FermionSite(conserve='N')
            >>> p_state = ['empty', 'full'] * 3
            >>> psi = tenpy.networks.mps.MPS.from_product_state([fermion]*6, p_state, "finite")
            >>> CdC = psi.correlation_function("Cd", "C")  # optionally: use `hermitian=True`
            >>> psi.correlation_function("C", "Cd")[1, 2] == -CdC[2, 1]
            True
            >>> np.all(np.diag(CdC) == psi.expectation_value("Cd C"))  # "Cd C" is equivalent to "N"
            True

        See also
        --------
        expectation_value_term : for a single combination of `i` and `j` of ``A_i B_j```.
        term_correlation_function_right : for correlations between multi-site terms, fix left term.
        term_correlation_function_left : for correlations between multi-site terms, fix right term.
        """
        if opstr is not None:
            autoJW = False
        ops1, ops2, sites1, sites2, opstr = self._correlation_function_args(
            ops1, ops2, sites1, sites2, opstr)
        if ((len(sites1) > 2 * len(sites2) and min(sites2) > max(sites1) - len(sites2))
                or (len(sites2) > 2 * len(sites1) and min(sites1) > max(sites2) - len(sites1))):
            warnings.warn(
                "Inefficient evaluation of MPS.correlation_function(), "
                "it's probably faster to use MPS.term_correlation_function_left()",
                stacklevel=2)
        if autoJW and not all([isinstance(op1, str) for op1 in ops1]):
            warnings.warn("Non-string operator: can't auto-determine Jordan-Wigner!", stacklevel=2)
            autoJW = False
        if autoJW:
            need_JW = []
            for i in sites1:
                need_JW.append(self.sites[i % self.L].op_needs_JW(ops1[i % len(ops1)]))
            for j in sites2:
                need_JW.append(self.sites[j % self.L].op_needs_JW(ops1[j % len(ops1)]))
            if any(need_JW):
                if not all(need_JW):
                    raise ValueError("Some, but not any operators need 'JW' string!")
                if not str_on_first:
                    raise ValueError("Need Jordan Wigner string, but `str_on_first`=False`")
                opstr = ['JW']
        if hermitian and np.any(sites1 != sites2):
            warnings.warn("MPS correlation function can't use the hermitian flag", stacklevel=2)
            hermitian = False
        C = np.empty((len(sites1), len(sites2)), dtype=complex)
        for x, i in enumerate(sites1):
            # j > i
            j_gtr = sites2[sites2 > i]
            if len(j_gtr) > 0:
                C_gtr = self._corr_up_diag(ops1, ops2, i, j_gtr, opstr, str_on_first, True)
                C[x, (sites2 > i)] = C_gtr
                if hermitian:
                    C[x + 1:, x] = np.conj(C_gtr)
            # j == i
            j_eq = sites2[sites2 == i]
            if len(j_eq) > 0:
                # on-site correlation function
                op1, _ = self.get_op(ops1, i)
                op2, _ = self.get_op(ops2, i)
                op12 = npc.tensordot(op1, op2, axes=['p*', 'p'])
                C[x, (sites2 == i)] = self.expectation_value(op12, i, [['p'], ['p*']])
        if not hermitian:
            #  j < i
            for y, j in enumerate(sites2):
                i_gtr = sites1[sites1 > j]
                if len(i_gtr) > 0:
                    C[(sites1 > j), y] = self._corr_up_diag(ops2, ops1, j, i_gtr, opstr,
                                                            str_on_first, False)
                    # exchange ops1 and ops2 : they commute on different sites,
                    # but we apply opstr after op1 (using the last argument = False)
        return self._normalize_exp_val(C)

    def expectation_value_term(self, term, autoJW=True):
        r"""Expectation value  ``<bra|op_{i0}op_{i1}...op_{iN}|ket>``.

        Calculates the expectation value of a tensor product of single-site operators
        acting on different sites `i0`, `i1`, ... (not necessarily next to each other).
        In other words, evaluate the expectation value of a term ``op0_i0 op1_i1 op2_i2 ...``.

        For example the contraction of three one-site operators on sites `i0`,
        `i1=i0+1`, `i2=i0+3` would look like::

            |          .--S--B[i0]---B[i0+1]--B[i0+2]--B[i0+3]--.
            |          |     |       |        |        |        |
            |         LP[i0]op1     op2       |       op3       RP[i0+3]
            |          |     |       |        |        |        |
            |          .--S--B*[i0]--B*[i0+1]-B*[i0+2]-B*[i0+3]-.


        Parameters
        ----------
        term : list of (str, int)
            List of tuples ``op, i`` where `i` is the MPS index of the site the operator
            named `op` acts on.
            The order inside `term` determines the order in which they act
            (in the mathematical convention: the last operator in `term` is right-most,
            so it acts first on a ket).
        autoJW : bool
            If True (default), automatically insert Jordan Wigner strings for Fermions as needed.

        Returns
        -------
        exp_val : float/complex
            The expectation value of the tensorproduct of the given onsite operators,
            ``<bra|op_i0 op_i1 ... op_iN |ket>``.

            .. warning ::

                The :class:`MPSEnvironment` variant of this method takes the accumulated MPS
                :attr:`~tenpy.networks.mps.MPS.norm` into account, which is non-trivial e.g. when you
                used `apply_local_op` with non-unitary operators.

                In contrast, the :class:`MPS` variant of this method *ignores* the `norm`,
                i.e. returns the expectation value for the normalized state.

        See also
        --------
        correlation_function : efficient way to evaluate many correlation functions.

        Examples
        --------

        .. testsetup :: MPS.expectation_value_term

            spin_half = tenpy.networks.site.SpinHalfSite(conserve=None)
            psi = tenpy.networks.mps.MPS.from_product_state([spin_half]*8, ['up']*8)

        .. doctest :: MPS.expectation_value_term

            >>> a = psi.expectation_value_term([('Sx', 2), ('Sz', 4)])
            >>> b = psi.expectation_value_term([('Sz', 4), ('Sx', 2)])
            >>> c = psi.expectation_value_multi_sites(['Sz', 'Id', 'Sx'], i0=2)
            >>> assert a == b == c
        """
        # strategy: translate term into a list "ops" to be used for `expectation_value_multi_sites`
        ops, i_min, has_extra_JW = self._term_to_ops_list(term, autoJW)
        if has_extra_JW:
            raise ValueError("Odd number of operators which need a Jordan Wigner string")
        return self.expectation_value_multi_sites(ops, i_min)

    def expectation_value_terms_sum(self, term_list):
        """Calculate expectation values for a bunch of terms and sum them up.

        This is equivalent to the following expression::

            sum([self.expectation_value_term(term)*strength for term, strength in term_list])

        However, for efficiency, the term_list is converted to an MPO and the expectation value
        of the MPO is evaluated.

         .. warning ::

             This function works only for finite bra and ket and does not include normalization factors.

        Parameters
        ----------
        term_list : :class:`~tenpy.networks.terms.TermList`
            The terms and prefactors (`strength`) to be summed up.

        Returns
        -------
        terms_sum : (complex) float
            Equivalent to the expression
            ``sum([self.expectation_value_term(term)*strength for term, strength in term_list])``.
        _mpo :
            Intermediate results: the generated MPO.
            For a finite MPS, ``terms_sum = _mpo.expectation_value(self)``, for an infinite MPS
            ``terms_sum = _mpo.expectation_value(self) * self.L``

        See also
        --------
        expectation_value_term : evaluates a single `term`.
        tenpy.networks.mpo.MPO.expectation_value : expectation value density of an MPO.
        """
        # this implementation assumes that bra and ket are different. the implementation in MPS
        # overrides this.
        from . import mpo
        if not self.finite:
            raise ValueError("MPO expectation values only works for a finite MPSEnvironment")
        # conversion
        ot, ct = term_list.to_OnsiteTerms_CouplingTerms(self.sites)
        bc = 'finite' if self.finite else 'infinite'
        mpo_graph = mpo.MPOGraph.from_terms((ot, ct), self.sites, bc)
        mpo_ = mpo_graph.build_MPO()

        env = mpo.MPOEnvironment(self.bra, mpo_, self.ket)
        terms_sum = env.full_contraction(0)  # handles explicit_plus_hc
        return np.real_if_close(terms_sum), mpo_

    def term_correlation_function_right(self,
                                        term_L,
                                        term_R,
                                        i_L=0,
                                        j_R=None,
                                        autoJW=True,
                                        opstr=None):
        """Correlation function between (multi-site) terms, moving the right term, fix left term.

        For ``term_L = [('A', 0), ('B', 1)]`` and ``term_R = [('C', 0), ('D', 1)]``,
        calculate the correlation function :math:`A_{i+0} B_{i+1} C_{j+0} D_{j+1}`
        for fixed `i` and varying `j` according to `i_L`/`j_R`.
        The terms may not overlap.
        For fermions, the order of the terms is following the usual mathematical convention,
        where term_R acts first on a physical ket.

        .. warning ::

            This function assumes that bra and ket are normalized, i.e. for MPSEnvironment.
            Thus you may want to take into account :attr:`MPS.norm` of both `bra` and `ket`.

        Parameters
        ----------
        term_L, term_R : list of (str, int)
            Each a term representing a sum of operators on different sites, e.g.,
            ``[('Sz', 0), ('Sz', 1)]`` or ``[('Cd', 0), ('C', 1)]``.
        i_L : int
            Offset added to the indices of `term_L`.
        j_R : list of int | None
            List of offsets to be added to the indices of `term_R`.
            Is sorted before use, i.e. the order is ignored.
            For **finite** MPS, `None` defaults to ``range(j0, L)``,
            where `j0` is chosen such that `term_R` starts one site right of the `term_L`.
            For **infinite** MPS, `None` defaults to ``range(L, 11*L, L)``, i.e.,
            one term per MPS unit cell for a distance of up to 10 unit cells.
        autoJW : bool
            Whether to automatically take care of Jordan-Wigner strings.
        opstr : str
            Force an intermediate operator string to used inbetween the terms.
            Can only be used in combination with ``autoJW=False``.

        Returns
        -------
        corrs : 1D array
            Values of the correlation function, one for each entry in the list `j_R`.

            .. warning ::

                The :class:`MPSEnvironment` variant of this method takes the accumulated MPS
                :attr:`~tenpy.networks.mps.MPS.norm` into account, which is non-trivial e.g. when you
                used `apply_local_op` with non-unitary operators.

                In contrast, the :class:`MPS` variant of this method *ignores* the `norm`,
                i.e. returns the expectation value for the normalized state.

        See also
        --------
        correlation_function : varying both `i` and `j` at once.
        term_list_correlation_function_right : generalization to sums of terms on the left/right.
        """
        assert opstr is None or not autoJW
        if j_R is None:
            if self.finite:
                j0 = i_L + max([t[1] for t in term_L]) + 1 - min([t[1] for t in term_R])
                j_R = range(j0, self.L - max([t[1] for t in term_R] + [0]))
            else:
                j_R = range(self.L, 11 * self.L, self.L)
        else:
            j_R = np.sort(j_R)
        ops_R, j_min, has_extra_JW = self._term_to_ops_list(term_R, autoJW, j_R[0])
        j_min = j_min - j_R[0]
        if autoJW:
            opstr = 'JW' if has_extra_JW else None
        ops_L, i_min, has_extra_JW = self._term_to_ops_list(term_L, autoJW, i_L, has_extra_JW)
        if autoJW and has_extra_JW:
            raise ValueError("Odd total number of operators which need a Jordan Wigner string")
        CL = self._corr_ops_LP(ops_L, i_min)
        i = i_min + len(ops_L)  # CL is contraction strictly left of site `i`
        if i > j_R[0] + j_min:
            raise ValueError("i_L/j_R not such that term_L is left of term_R")
        bra, ket = self._get_bra_ket()
        axes_contr = [['vL*'] + ket._get_p_label('*'), ['vR*'] + ket._p_label]
        result = []
        for j in j_R:
            j = j + j_min  # start ops_R on site `j`
            assert i <= j
            for k in range(i, j):
                assert i == k
                # contract CL with tensors on site `k`
                B_ket = ket.get_B(k, form='B')
                CL = npc.tensordot(CL, B_ket, axes=['vR', 'vL'])
                if opstr is not None:
                    opstr_k = self.sites[self._to_valid_index(k)].get_op(opstr)
                    CL = npc.tensordot(opstr_k, CL, axes=['p*', 'p'])
                B_bra = bra.get_B(k, form='B')
                CL = npc.tensordot(B_bra.conj(), CL, axes=axes_contr)
                i = k + 1
            # recalculate the operators (alternatively: manually shift them)
            ops_R, _, _ = self._term_to_ops_list(term_R, autoJW, j - j_min)
            CR = self._corr_ops_RP(ops_R, j)
            result.append(npc.inner(CL, CR, axes=[['vR', 'vR*'], ['vL', 'vL*']]))
        return self._normalize_exp_val(result)

    def term_correlation_function_left(self,
                                       term_L,
                                       term_R,
                                       i_L=None,
                                       j_R=0,
                                       autoJW=True,
                                       opstr=None):
        """Correlation function between (multi-site) terms, moving the left term, fix right term.

        Same as :meth:`term_correlation_function_right`, but vary index `i` of the left term
        instead of the `j` of the right term.
        """
        assert opstr is None or not autoJW
        if i_L is None:
            if self.finite:
                raise ValueError("No default set for finite MPS")
            else:
                i_L = range(-self.L, -11 * self.L, -self.L)
        else:
            i_L = np.sort(i_L)[::-1]
        ops_R, j_min, has_extra_JW = self._term_to_ops_list(term_R, autoJW, j_R)
        if autoJW:
            opstr = 'JW' if has_extra_JW else None
        ops_L, i_min, has_extra_JW = self._term_to_ops_list(term_L, autoJW, i_L[0], has_extra_JW)
        i_min = i_min - i_L[0]
        if autoJW and has_extra_JW:
            raise ValueError("Odd total number of operators which need a Jordan Wigner string")
        CR = self._corr_ops_RP(ops_R, j_min)
        j = j_min  # CR is contraction including site `j`
        if i_L[0] + i_min + len(ops_L) - 1 > j:
            raise ValueError("i_L/j_R not such that term_L is left of term_R")
        result = []
        bra, ket = self._get_bra_ket()
        axes_contr = [ket._p_label + ['vL*'], bra._get_p_label('*') + ['vR*']]
        for i in i_L:
            i0 = i + i_min + len(ops_L) - 1  # CL of term_L includes site `i0` as right-most
            assert i0 <= j
            for k in range(j - 1, i0, -1):
                # contract CR with tensors on site `k`
                B_ket = ket.get_B(k, form='B')
                CR = npc.tensordot(B_ket, CR, axes=['vR', 'vL'])
                if opstr is not None:
                    opstr_k = self.sites[self._to_valid_index(k)].get_op(opstr)
                    CR = npc.tensordot(opstr_k, CR, axes=['p*', 'p'])
                B_bra = bra.get_B(k, form='B')
                CR = npc.tensordot(CR, B_bra.conj(), axes_contr)
                j = k
            # recalculate the operators (alternatively: manually shift them)
            ops_L, _, _ = self._term_to_ops_list(term_L, autoJW, i, has_extra_JW)
            CL = self._corr_ops_LP(ops_L, i + i_min)
            result.append(npc.inner(CL, CR, axes=[['vR', 'vR*'], ['vL', 'vL*']]))
        return self._normalize_exp_val(result)

    def term_list_correlation_function_right(self,
                                             term_list_L,
                                             term_list_R,
                                             i_L=0,
                                             j_R=None,
                                             autoJW=True,
                                             opstr=None):
        """Correlation function between sums of multi-site terms, moving the right sum of term.

        Generalization of :meth:`term_correlation_function_right` to the case where
        `term_list_L` and `term_R` are sums of terms.
        This function calculates ``<bra|term_list_L[i_L] term_list_R[j]|ket> for j in j_R``.

        **Assumes** that overall terms with an odd number of operators requiring a Jordan-Wigner
        string don't contribute.
        (In systems conserving the fermionic particle number (parity), this is true.)

        Parameters
        ----------
        term_list_L, term_list_R : :class:`~tenpy.networks.terms.TermList`
            Each a `TermList` representing the sum of terms to be applied.
        i_L : int
            Offset added to all the indices of `term_list_L`.
        j_R : list of int | None
            List of offsets to be added to the indices of `term_list_R`.
            Is sorted before use, i.e. the order is ignored.
            For **finite** MPS, `None` defaults to ``range(j0, L)``,
            where `j0` is chosen such that `term_R` starts one site right of the `term_L`.
            For **infinite** MPS, `None` defaults to ``range(L, 11*L, L)``, i.e.,
            one term per MPS unit cell for a distance of up to 10 unit cells.
        autoJW : bool
            Whether to automatically take care of Jordan-Wigner strings.
        opstr : str
            Force an intermediate operator string to be used inbetween the terms.
            (Even used within the `term_list_L/R` for terms with smaller-than maximal support.)
            Can only be used in combination with ``autoJW=False``.

        Returns
        -------
        corrs : 1D array
            Values of the correlation function, one for each entry in the list `j_R`.

            .. warning ::

                The :class:`MPSEnvironment` variant of this method takes the accumulated MPS
                :attr:`~tenpy.networks.mps.MPS.norm` into account, which is non-trivial e.g. when you
                used `apply_local_op` with non-unitary operators.

                In contrast, the :class:`MPS` variant of this method *ignores* the `norm`,
                i.e. returns the expectation value for the normalized state.

        See also
        --------
        term_correlation_function_right : version for a single term in both `term_list_L/R`.
        """
        assert opstr is None or not autoJW
        min_L, max_L = term_list_L.limits()
        min_R, max_R = term_list_R.limits()  # note: min_R can be negative!
        if j_R is None:
            if self.finite:
                j0 = i_L + max_L + 1 - min_L
                j_R = range(j0, self.L - max(0, max_R))
            else:
                j_R = range(self.L, 11 * self.L, self.L)
        else:
            j_R = np.sort(j_R)
        j0 = j_R[0]
        if i_L + max_L >= j0 + min_R:
            raise ValueError("i_L/i_R not such that term_list_L is left of term_list_R")
        if autoJW:
            opstr_fill = {True: 'JW', False: 'Id'}  # key: whether JW is needed
        else:
            opstr_fill = {False: 'Id' if opstr is None else opstr}
            # True key not needed: we don't check for JW!
        all_ops_R = []
        need_JW_R = []
        for term_R in term_list_R.terms:
            ops_R, j_min, need_JW = self._term_to_ops_list(term_R, autoJW, j0)
            need_JW_R.append(need_JW)
            if j_min > j0 + min_R:
                # fill ops_R such that the left-most op acts at site `j0 + min_R`
                ops_R = [opstr_fill[need_JW]] * (j_min - (j0 + min_R)) + ops_R
            all_ops_R.append(ops_R)
        i = i_L + max_L + 1  # CL is contraction strictly left of site i
        CLs = {}  # (need_JW, qtotal...) -> sum_CL
        # where sum_CL = sum(CL(term_L) * strength) for term, strength in term_list_L
        # with given `qtotal`
        for term_L, strength in term_list_L:
            ops_L, i_min, need_JW = self._term_to_ops_list(term_L, autoJW, i_L, None)
            if i_min + len(ops_L) < i:
                ops_L = ops_L + [opstr_fill[need_JW]] * (i - (i_min + len(ops_L)))
            CL = self._corr_ops_LP(ops_L, i_min)
            key = (need_JW, ) + tuple(CL.qtotal)
            if key not in CLs:
                CLs[key] = strength * CL
            else:
                CLs[key] = CLs[key] + strength * CL
        bra, ket = self._get_bra_ket()
        axes_contr = [['vL*'] + ket._get_p_label('*'), ['vR*'] + ket._p_label]
        result = []
        for j in j_R:
            j = j + min_R  # start ops_R on site `j`
            assert i <= j
            for k in range(i, j):
                assert i == k
                # contract CL with tensors on site `k`
                B_ket = ket.get_B(k, form='B')
                B_bra = bra.get_B(k, form='B')
                for key, CL in CLs.items():
                    need_JW = key[0]
                    CL = npc.tensordot(CL, B_ket, axes=['vR', 'vL'])
                    if opstr_fill[need_JW] != 'Id':
                        opstr_k = self.sites[self._to_valid_index(k)].get_op(opstr_fill[need_JW])
                        CL = npc.tensordot(opstr_k, CL, axes=['p*', 'p'])
                    CLs[key] = npc.tensordot(B_bra.conj(), CL, axes=axes_contr)
                i = k + 1
            res = 0.
            for ops_R, need_JW, strength in zip(all_ops_R, need_JW_R, term_list_R.strength):
                CR = self._corr_ops_RP(ops_R, j)
                key = (need_JW, ) + tuple(self.sites[0].leg.chinfo.make_valid(-CR.qtotal))
                CL = CLs.get(key, None)
                if CL is None:
                    continue  # nothing to pair up with
                res = res + strength * npc.inner(CL, CR, axes=[['vR', 'vR*'], ['vL', 'vL*']])
            result.append(res)
        return self._normalize_exp_val(result)

    def _term_to_ops_list(self, term, autoJW=True, i_offset=0, JW_from_right=False):
        """Translate a `term` to a list of operators (one per site).

        Parameters
        ----------
        term : list of (str, int)
            List of tuples ``op, i`` where `i` is the MPS index of the site the operator
            named `op` acts on.
            The order inside `term` determines the order in which they act
            (in the mathematical convention: the last operator in `term` is right-most,
            so it acts first on a ket).
            If autoJW is False, we also accept npc arrays for `op`.
        autoJW : bool
            If True (default), automatically insert Jordan Wigner strings for Fermions as needed.
        i_offset : int
            Offset to be added to the site-indices in the `term`.
        JW_from_right : bool | None
            If set to True, a JW-string is coming in from the right. Corresponding `JW` operators
            are added to `ops`.
            If `None`, use

        Returns
        -------
        ops : list of :class:`~tenpy.linalg.np_conserved.Array`
            Operators, one per site starting with `i_min`, i.e. ``ops[i]`` acts on `i_min`+`i`.
        i_min : int
            Index of the left-most site on which `ops` act (including the `i_offset`).
        has_extra_JW : bool
            True if there is an odd number of terms which require a Jordan-Wigner string,
            i.e., if there is a JW string coming out to the left.
            If `JW_from_right` was initially `None`, it is the value chosen for `JW_from_right`.
        """
        assert not (JW_from_right and not autoJW)
        term = list(term)
        i_min = min([t[1] for t in term])
        i_max = max([t[1] for t in term])
        ops = [[] for i in range((i_max - i_min + 1))]
        count_JW = 0
        for op, i in term:
            j = i - i_min  # index in ops
            ops[j].append(op)
            if autoJW and self.sites[self._to_valid_index(i + i_offset)].op_needs_JW(op):
                count_JW += 1
                for k in range(j):
                    ops[k].append('JW')
        if JW_from_right is None:
            JW_from_right = (count_JW % 2 == 1)
            if JW_from_right:
                count_JW -= 1  # still return True for `has_extra_JW`
        if JW_from_right:
            count_JW += 1
            for op_i in ops:
                op_i.append('JW')
        for j in range(len(ops)):
            site = self.sites[self._to_valid_index(j + i_min + i_offset)]
            i = j + i_min + i_offset
            ops[j] = site.multiply_operators(ops[j])
        return ops, i_min + i_offset, (count_JW % 2 == 1)

    def _corr_up_diag(self, ops1, ops2, i, j_gtr, opstr, str_on_first, apply_opstr_first):
        """correlation function above the diagonal: for fixed i and all j in j_gtr, j > i."""
        op1, _ = self.get_op(ops1, i)
        opstr1, _ = self.get_op(opstr, i)
        if opstr1 is not None and str_on_first:
            axes = ['p*', 'p'] if apply_opstr_first else ['p', 'p*']
            op1 = npc.tensordot(op1, opstr1, axes=axes)
        bra, ket = self._get_bra_ket()
        theta_ket = ket.get_B(i, form='Th')
        theta_bra = bra.get_B(i, form='Th')
        C = npc.tensordot(op1, theta_ket, axes=['p*', 'p'])
        C = self._contract_with_LP(C, i)
        axes_contr = [['vL*'] + ket._get_p_label('*'), ['vR*'] + ket._p_label]
        C = npc.tensordot(theta_bra.conj(), C, axes=axes_contr)
        # C has legs 'vR*', 'vR'
        js = list(j_gtr[::-1])  # stack of j, sorted *descending*
        res = []
        for r in range(i + 1, js[0] + 1):  # js[0] is the maximum
            B_ket = ket.get_B(r, form='B')
            B_bra = bra.get_B(r, form='B')
            C = npc.tensordot(C, B_ket, axes=['vR', 'vL'])
            if r == js[-1]:
                op2, _ = self.get_op(ops2, r)
                Cij = npc.tensordot(op2, C, axes=['p*', 'p'])
                Cij = self._contract_with_RP(Cij, r)
                Cij.ireplace_labels(['vR*', 'vL*'], ['vL', 'vR'])
                Cij = npc.inner(B_bra.conj(), Cij, axes='labels')
                res.append(Cij)
                js.pop()
            if len(js) > 0:
                op, _ = self.get_op(opstr, r)
                if op is not None:
                    C = npc.tensordot(op, C, axes=['p*', 'p'])
                C = npc.tensordot(B_bra.conj(), C, axes=axes_contr)
        return res

    def _corr_ops_LP(self, operators, i0):
        """Contract the left part of a correlation function.

        Same as :meth:`expectation_value_multi_sites`, but with the right-most legs left open,
        with labels ``'vR*', 'vR'``.
        """
        op = operators[0]
        if (isinstance(op, str)):
            op = self.sites[self._to_valid_index(i0)].get_op(op)
        bra, ket = self._get_bra_ket()
        theta_ket = ket.get_B(i0, form='Th')
        theta_bra = bra.get_B(i0, form='Th')
        C = npc.tensordot(op, theta_ket, axes=['p*', 'p'])
        C = self._contract_with_LP(C, i0)  # 'p' 'vR*' 'vR'
        axes_contr = [['vL*'] + ket._get_p_label('*'), ['vR*'] + ket._p_label]
        C = npc.tensordot(theta_bra.conj(), C, axes=axes_contr)
        for j in range(1, len(operators)):
            op = operators[j]  # the operator
            is_str = isinstance(op, str)
            i = i0 + j  # the site it acts on
            B_ket = ket.get_B(i, form='B')
            C = npc.tensordot(C, B_ket, axes=['vR', 'vL'])
            if not (is_str and op == 'Id'):
                if is_str:
                    op = self.sites[self._to_valid_index(i)].get_op(op)
                C = npc.tensordot(op, C, axes=['p*', 'p'])
            B_bra = bra.get_B(i, form='B')
            C = npc.tensordot(B_bra.conj(), C, axes=axes_contr)
        return C

    def _corr_ops_RP(self, operators, i0):
        """Contract the right part of a correlation function.

        Same as :meth:`expectation_value_multi_sites`, but with the left-most part open
        and **excluding** the singular values `S`, with legs ``'vL', 'vL*'``.
        """
        op = operators[-1]
        imax = i0 + len(operators) - 1
        bra, ket = self._get_bra_ket()
        C = npc.eye_like(ket.get_B(imax, 'B'), 'vR', ['vR', 'vL'])
        C = self._contract_with_RP(C, imax)  # 'vL' 'vL*'
        axes_contr = [['vR*'] + ket._get_p_label('*'), ['vL*'] + ket._p_label]
        for j in reversed(range(len(operators))):
            op = operators[j]  # the operator
            is_str = isinstance(op, str)
            i = i0 + j  # the site it acts on
            B_ket = ket.get_B(i, form='B')
            C = npc.tensordot(B_ket, C, axes=['vR', 'vL'])
            if not (is_str and op == 'Id'):
                if is_str:
                    op = self.sites[self._to_valid_index(i)].get_op(op)
                C = npc.tensordot(op, C, axes=['p*', 'p'])
            B_bra = bra.get_B(i, form='B')
            C = npc.tensordot(B_bra.conj(), C, axes=axes_contr)
        return C

    def _expectation_value_args(self, ops, sites, axes):
        """parse the arguments of self.expectation_value()"""
        ops = npc.to_iterable_arrays(ops)
        if any(isinstance(op, str) for op in ops):
            n = 1
        else:
            s = 0 if sites is None else to_iterable(sites)[0]
            n = ops[s % len(ops)].rank // 2  # same as int(rank/2)
        L = self.L
        if sites is None:
            if self.finite:
                sites = range(L - (n - 1))
            else:
                sites = range(L)
        sites = to_iterable(sites)
        if axes is None:
            if n == 1:
                axes = (['p'], ['p*'])
            else:
                axes = (self._get_p_labels(n), self._get_p_labels(n, True))
        # check number of axes
        ax_p, ax_pstar = axes
        if len(ax_p) != n or len(ax_pstar) != n:
            raise ValueError("Len of axes does not match to n-site operator with n=" + str(n))
        return ops, sites, n, axes

    def _correlation_function_args(self, ops1, ops2, sites1, sites2, opstr):
        """get default arguments of self.correlation_function()"""
        if sites1 is None:
            sites1 = range(0, self.L)
        elif isinstance(sites1, int):
            sites1 = range(0, sites1)
        if sites2 is None:
            sites2 = range(0, self.L)
        elif isinstance(sites2, int):
            sites2 = range(0, sites2)
        ops1 = npc.to_iterable_arrays(ops1)
        ops2 = npc.to_iterable_arrays(ops2)
        opstr = npc.to_iterable_arrays(opstr)
        sites1 = np.sort(sites1)
        sites2 = np.sort(sites2)
        return ops1, ops2, sites1, sites2, opstr

    def _replace_p_label(self, A, s):
        """Return npc Array `A` with replaced label, ``'p' -> 'p'+s``.

        This is done for each of the 'physical labels' in :attr:`_p_label`. With a clever use of
        this function, the re-implementation of various functions (like get_theta) in derived
        classes with multiple legs per site can be avoided.
        """
        return A.replace_label('p', 'p' + s)
        #  return A.replace_labels(self._p_label, self._get_p_label(s))

    def _get_p_label(self, s):
        """return  self._p_label with additional string `s`."""
        return ['p' + s]
        #  return [lbl + s for lbl in self._p_label]

    def _get_p_labels(self, ks, star=False):
        """Join ``self._get_p_label(str(k)) for k in range(ks)`` to a single list."""
        if star:
            return ['p' + str(k) + '*' for k in range(ks)]
            #  return [lbl + str(k) + '*' for k in range(ks) for lbl in self._p_label]
        else:
            return ['p' + str(k) for k in range(ks)]
            #  return [lbl + str(k) for k in range(ks) for lbl in self._p_label]

    def _to_valid_index(self, i):
        """Make sure `i` is a valid index (depending on `finite`)."""
        if not self.finite:
            return i % self.L
        if i < 0:
            i += self.L
        if i >= self.L or i < 0:
            raise KeyError("i = {0:d} out of bounds for finite MPS".format(i))
        return i

    def get_op(self, op_list, i):
        """Given a list of operators, select the one corresponding to site `i`.

        Parameters
        ----------
        op_list : list of {str | npc.array}
            List of operators from which we choose. We assume that ``op_list[j]`` acts on site
            ``j``. If the length is shorter than `L`, we repeat it periodically.
            Strings are translated using :meth:`~tenpy.networks.site.Site.get_op` of site `i`.
        i : int
            Index of the site on which the operator acts.

        Returns
        -------
        op : npc.array
            One of the entries in `op_list`, not copied.
        needs_JW : bool
            If the operator needs a JW string. Always ``False`` if the entry of ``op_list`` is
            an array.
        """
        if self.finite and (i > self.L or i < 0):
            raise ValueError("i = {0:d} out of bounds for finite MPS".format(i))
        op = op_list[i % len(op_list)]
        if (isinstance(op, str)):
            site = self.sites[i % self.L]
            needs_JW = site.op_needs_JW(op)
            op = site.get_op(op)
        else:
            needs_JW = False
        return op, needs_JW


    @abstractmethod
    def _normalize_exp_val(self, value):
        """Return `value`, but multiply with bra.norm and ket.norm for MPSEnvironment."""
        ...

    @abstractmethod
    def _contract_with_LP(self, C, i):
        """contract `theta` with `self.get_LP(i)`.

        If `bra` = `ket`, this is a trivial relabeling of legs `vL` -> `vR*`."""
        ...

    @abstractmethod
    def _contract_with_RP(self, C, i):
        """contract `C` with `self.get_RP(i)`.

        If `bra` = `ket`, this is a trivial relabeling of legs `vR` -> `vL*`."""
        ...

    @abstractmethod
    def _get_bra_ket(self):
        """Return bra and ket providing :meth:`get_B` for expectation values."""
        ...
        # for MPS: return self, self
        # for MPSEnvironment: return self.bra, self.ket
        # but don't put this as attributes to avoid cyclic references...


class MPS(BaseMPSExpectationValue):
    r"""A Matrix Product State, finite (MPS) or infinite (iMPS).

    Parameters
    ----------
    sites : list of :class:`~tenpy.networks.site.Site`
        Defines the local Hilbert space for each site.
    Bs : list of :class:`~tenpy.linalg.np_conserved.Array`
        The 'matrices' of the MPS. Labels are ``vL, vR, p`` (in any order).
    SVs : list of 1D array
        The singular values on *each* bond. Should always have length `L+1`.
        Entries out of :attr:`nontrivial_bonds` are ignored.
    bc : ``'finite' | 'segment' | 'infinite'``
        Boundary conditions as described in the table of the module doc-string.
    form : (list of) {``'B' | 'A' | 'C' | 'G' | 'Th' | None`` | tuple(float, float)}
        The form of the stored 'matrices', see table in module doc-string.
        A single choice holds for all of the entries.

    Attributes
    ----------
    sites : list of :class:`~tenpy.networks.site.Site`
        Defines the local Hilbert space for each site.
    bc : {'finite', 'segment', 'infinite'}
        Boundary conditions as described in above table.
    form : list of {``None``, tuple(float, float)}
        Describes the canonical form on each site.
        ``None`` means non-canonical form.
        For ``form = (nuL, nuR)``, the stored ``_B[i]`` are
        ``s**form[0] -- Gamma -- s**form[1]`` (in Vidal's notation).
    chinfo : :class:`~tenpy.linalg.np_conserved.ChargeInfo`
        The nature of the charge.
    dtype : type
        The data type of the ``_B``.
    norm : float
        The overall norm of the state, i.e. ``sqrt(<psi|psi>)`` - the tensors are kept normalized.
        Ignored for (normalized) :meth:`expectation_value` and co,
        but important for :meth:`overlap` and expectation value methods of :class:`MPSEnvironment`.
    grouped : int
        Number of sites grouped together, see :meth:`group_sites`.
    segment_boundaries : tuple of :class:`~tenpy.linalg.np_conserved.Array` | (None, None)
        Only defined for 'segment' `bc` if :meth:`canonical_form_finite` has been called.
        If defined, it contains the `U_L` and `V_R` that would be returned by that function.
    _B : list of :class:`npc.Array`
        The 'matrices' of the MPS. Labels are ``vL, vR, p`` (in any order).
        We recommend using :meth:`get_B` and :meth:`set_B`, which will take care of the different
        canonical forms.
    _S : list of {``None``, 1D array, :class:`~tenpy.linalg.np_conserved.Array`}
        The singular values on each virtual bond, length ``L+1``.
        May be ``None`` if the MPS is not in canonical form.
        Otherwise, ``_S[i]`` is to the left of ``_B[i]``.
        We recommend using :meth:`get_SL`, :meth:`get_SR`, :meth:`set_SL`, :meth:`set_SR`, which
        takes proper care of the boundary conditions.
        Sometimes (e.g. during DMRG with an enabled mixer), entries may temporarily be
        a non-diagonal :class:`tenpy.linalg.np_conserved.Array` to be inserted between the
        left canonical 'A' tensors on the left and right-canonical _B[i] on the right.
    _valid_forms : dict
        Class attribute.
        Mapping for canonical forms to a tuple ``(nuL, nuR)`` indicating that
        ``self._B[i] = s[i]**nuL -- Gamma[i] -- s[i]**nuR`` is saved.
    _valid_bc : tuple of str
        Class attribute. Possible valid boundary conditions.
    _transfermatrix_keep : int
        How many states to keep at least when diagonalizing a :class:`TransferMatrix`.
        Important if the state develops a near-degeneracy.
    _p_label, _B_labels : list of str
        Class attribute. `_p_label` defines the physical legs of the B-tensors, `_B_labels` lists
        all the labels of the B tensors. Used by methods like :meth:`get_theta` to avoid
        the necessity of re-implementations for derived classes like the
        :class:`~tenpy.networks.purification_mps.Purification_MPS` if just the number of physical
        legs changed.
    """
    # Canonical form conventions: the saved B = s**nu[0]--Gamma--s**nu[1].
    # For the canonical forms, ``nu[0] + nu[1] = 1``
    _valid_forms = {
        'A': (1., 0.),
        'C': (0.5, 0.5),
        'B': (0., 1.),
        'G': (0., 0.),  # like Vidal's `Gamma`.
        'Th': (1., 1.),
        None: None,  # means 'not in any canonical form'
    }

    # valid boundary conditions. Don't overwrite this!
    _valid_bc = ('finite', 'segment', 'infinite')
    # the "physical" labels for each B
    _p_label = ['p']
    # All labels of each tensor in _B (order is used!)
    _B_labels = ['vL', 'p', 'vR']

    def __init__(self, sites, Bs, SVs, bc='finite', form='B', norm=1.):
        self.sites = list(sites)
        assert len(self.sites) > 0, "MPS need at least one site"
        self.chinfo = self.sites[0].leg.chinfo
        self.dtype = dtype = np.result_type(*[B.dtype for B in Bs])
        self.form = self._parse_form(form)
        self.bc = bc  # one of ``self._valid_bc = ('finite', 'periodic', 'segment')``
        self.norm = norm
        self.grouped = 1
        self.segment_boundaries = (None, None)

        # make copies of Bs and SVs
        self._B = [B.astype(dtype, copy=True).itranspose(self._B_labels) for B in Bs]
        self._S = [None] * (self.L + 1)
        for i in range(self.L + 1)[self.nontrivial_bonds]:
            if isinstance(SVs[i], npc.Array):
                self._S[i] = SVs[i].copy()
            else:
                self._S[i] = np.array(SVs[i], dtype=np.float64)
        if self.bc == 'infinite':
            self._S[-1] = self._S[0]
        elif self.bc == 'finite':
            self._S[0] = self._S[-1] = np.ones([1], dtype=np.float64)
        self._transfermatrix_keep = 1
        self.test_sanity()

    def test_sanity(self):
        """Sanity check, raises ValueErrors, if something is wrong."""
        if self.bc not in self._valid_bc:
            raise ValueError("invalid boundary condition: " + repr(self.bc))
        if len(self._B) != self.L:
            raise ValueError("wrong len of self._B")
        if len(self._S) != self.L + 1:
            raise ValueError("wrong len of self._S")
        assert len(self.form) == self.L
        for f in self.form:
            if f is not None:
                assert isinstance(f, tuple)
                assert len(f) == 2
        for i, B in enumerate(self._B):
            if B.get_leg_labels() != self._B_labels:
                raise ValueError("B has wrong labels {0!r}, expected {1!r}".format(
                    B.get_leg_labels(), self._B_labels))
            if len(self._S[i + 1].shape) == 1:
                if self._S[i].shape[-1] != B.get_leg('vL').ind_len or \
                        self._S[i+1].shape[0] != B.get_leg('vR').ind_len:
                    raise ValueError("shape of B incompatible with len of singular values")
                if not self.finite or i + 1 < self.L:
                    B2 = self._B[(i + 1) % self.L]
                    B.get_leg('vR').test_contractible(B2.get_leg('vL'))
            else:
                assert len(self._S[i + 1].shape) == 2  # special case during DMRG with mixer,
                # important for simulation resume while mixer is on
                # we should have a well-defined form everywhere
                B = self.get_B(i, form='Th')
                B2 = self.get_B(i + 1, form='B')
                # and be able to contract Th-B
                B.get_leg('vR').test_contractible(B2.get_leg('vL'))
                # (but not necessarily A-B, as we have it on the first bond at DMRG checkpoints)
            assert self.form[i] in self._valid_forms.values()
        if self.bc == 'finite':
            if len(self._S[0]) != 1 or len(self._S[-1]) != 1:
                raise ValueError("non-trivial outer bonds for finite MPS")
        elif self.bc == 'infinite':
            if np.any(self._S[self.L] != self._S[0]):
                raise ValueError("iMPS with S[0] != S[L]")

    def copy(self):
        """Returns a copy of `self`.

        The copy still shares the sites, chinfo, and LegCharges of the B tensors, but the values of
        B and S are deeply copied.
        """
        # __init__ makes deep copies of B, S
        cp = self.__class__(self.sites, self._B, self._S, self.bc, self.form, self.norm)
        cp.grouped = self.grouped
        cp._transfermatrix_keep = self._transfermatrix_keep
        cp.segment_boundaries = getattr(self, "segment_boundaries", (None, None))
        return cp

    def save_hdf5(self, hdf5_saver, h5gr, subpath):
        """Export `self` into a HDF5 file.

        This method saves all the data it needs to reconstruct `self` with :meth:`from_hdf5`.

        Specifically, it saves
        :attr:`sites`,
        :attr:`chinfo` (under these names),
        :attr:`_B` as ``"tensors"``,
        :attr:`_S` as ``"singular_values"``,
        :attr:`bc` as ``"boundary_condition"``, and
        :attr:`form` converted to a single array of shape (L, 2) as ``"canonical_form"``,
        Moreover, it saves :attr:`norm`, :attr:`L`, :attr:`grouped` and
        :attr:`_transfermatrix_keep` (as "transfermatrix_keep") as HDF5 attributes, as well as
        the maximum of :attr:`chi` under the name "max_bond_dimension".

        Parameters
        ----------
        hdf5_saver : :class:`~tenpy.tools.hdf5_io.Hdf5Saver`
            Instance of the saving engine.
        h5gr : :class`Group`
            HDF5 group which is supposed to represent `self`.
        subpath : str
            The `name` of `h5gr` with a ``'/'`` in the end.
        """
        hdf5_saver.save(self.sites, subpath + "sites")
        hdf5_saver.save(self._B, subpath + "tensors")
        hdf5_saver.save(self._S, subpath + "singular_values")
        hdf5_saver.save(self.bc, subpath + "boundary_condition")
        hdf5_saver.save(np.array(self.form), subpath + "canonical_form")
        hdf5_saver.save(self.chinfo, subpath + "chinfo")
        segment_boundaries = getattr(self, "segment_boundaries", (None, None))
        hdf5_saver.save(self.segment_boundaries, subpath + "segment_boundaries")
        h5gr.attrs["norm"] = self.norm
        h5gr.attrs["grouped"] = self.grouped
        h5gr.attrs["transfermatrix_keep"] = self._transfermatrix_keep
        h5gr.attrs["L"] = self.L  # not needed for loading, but still useful metadata
        h5gr.attrs["max_bond_dimension"] = np.max(self.chi)  # same

    @classmethod
    def from_hdf5(cls, hdf5_loader, h5gr, subpath):
        """Load instance from a HDF5 file.

        This method reconstructs a class instance from the data saved with :meth:`save_hdf5`.

        Parameters
        ----------
        hdf5_loader : :class:`~tenpy.tools.hdf5_io.Hdf5Loader`
            Instance of the loading engine.
        h5gr : :class:`Group`
            HDF5 group which is represent the object to be constructed.
        subpath : str
            The `name` of `h5gr` with a ``'/'`` in the end.

        Returns
        -------
        obj : cls
            Newly generated class instance containing the required data.
        """
        obj = cls.__new__(cls)  # create class instance, no __init__() call
        hdf5_loader.memorize_load(h5gr, obj)

        obj.sites = hdf5_loader.load(subpath + "sites")
        obj._B = hdf5_loader.load(subpath + "tensors")
        obj._S = hdf5_loader.load(subpath + "singular_values")
        obj.bc = hdf5_loader.load(subpath + "boundary_condition")
        form = hdf5_loader.load(subpath + "canonical_form")
        obj.form = [tuple(f) for f in form]
        obj.norm = hdf5_loader.get_attr(h5gr, "norm")

        obj.grouped = hdf5_loader.get_attr(h5gr, "grouped")
        obj._transfermatrix_keep = hdf5_loader.get_attr(h5gr, "transfermatrix_keep")
        obj.chinfo = hdf5_loader.load(subpath + "chinfo")
        obj.dtype = np.result_type(*[B.dtype for B in obj._B])
        if "segment_boundaries" in h5gr:
            obj.segment_boundaries = hdf5_loader.load(subpath + "segment_boundaries")
        else:
            obj.segment_boundaries = (None, None)
        obj.test_sanity()
        return obj

    @classmethod
    def from_lat_product_state(cls, lat, p_state, allow_incommensurate=False, **kwargs):
        """Construct an MPS from a product state given in lattice coordinates.

        This is a wrapper around :meth:`from_product_state`.
        The purpose is to make the `p_state` argument independent of the `order` of the `Lattice`,
        and specify it in terms of lattice indices instead.

        Parameters
        ----------
        lat : :class:`~tenpy.models.lattice.Lattice`
            The underlying lattice defining the geometry and Hilbert Space.
        p_state : array_like of {int | str | 1D array}
            Defines the product state to be represented.
            Should be of dimension `lat.dim`+1, entries are indexed by lattice indices.
            Entries of the array as for the `p_state` argument of :meth:`from_product_state`.
            It gets tiled to the shape ``lat.shape``, if it is smaller.
        allow_incommensurate : bool
            Allow an incommensurate tiling of `p_state` to the full lattice.
            For example, if you pass ``p_state=[['up'], ['down']]`` with a
            :class:`tenpy.models.lattice.Chain`, this function raises an error for an odd number of
            sites in the Chain, but if you set `allow_incommensurate=True`, it will still work
            and give you a state with total Sz = +1/2 for odd sites (since total Sz=0 doesn't fit).
        **kwargs :
            Other keyword arguments as defined in :meth:`from_product_state`.
            `bc` is set by default from ``lat.bc_MPS``.

        Returns
        -------
        product_mps : :class:`MPS`
            An MPS representing the specified product state.

        Examples
        --------
        Let's first consider a :class:`~tenpy.models.lattice.Ladder` composed of a
        :class:`~tenpy.networks.site.SpinHalfSite` and a
        :class:`~tenpy.networks.site.FermionSite`.

        .. doctest : MPS.from_lat_product_state

            >>> spin_half = tenpy.networks.site.SpinHalfSite()
            >>> fermion = tenpy.networks.site.FermionSite()
            >>> ladder_i = tenpy.models.lattice.Ladder(2, [spin_half, fermion], bc_MPS="infinite")

        To initialize a state of up-spins on the spin sites and half-filled fermions, you can use:

        .. doctest : MPS.from_lat_product_state

            >>> p_state = [["up", "empty"], ["up", "full"]]
            >>> psi = tenpy.networks.MPS.from_lat_product_state(ladder_i, p_state)

        Note that the same `p_state` works for a finite lattice of even length, say ``L=10``, as
        well. We then just "tile" in x-direction, i.e., repeat the specified state 5 times:

        .. doctest : MPS.from_lat_product_state

            >>> ladder_f = tenpy.models.lattice.Ladder(10, [spin_half, fermion], bc_MPS="finite")
            >>> psi = tenpy.networks.MPS.from_lat_product_state(ladder_f, p_state)

        You can also easily half-fill a :class:`~tenpy.models.lattice.Honeycomb`, for example
        with only the `A` sites occupied, or as stripe parallel to the x-direction (`stripe_x`,
        alternating along `y` axis),
        or as stripes parallel to the y-direction (`stripe_y`, alternating along `x` axis).

        .. doctest : MPS.from_lat_product_state

            >>> honeycomb = tenpy.models.lattice.Honeycomb([4, 4], [fermion, fermion], bc_MPS="finite")
            >>> p_state_only_A = [[["empty", "full"]]]
            >>> psi_only_A = tenpy.networks.MPS.from_lat_product_state(honeycomb, p_state_only_A)
            >>> p_state_stripe_x = [[["empty", "empty"],
            ...                      ["full", "full"]]]
            >>> psi_stripe_x = tenpy.networks.MPS.from_lat_product_state(honeycomb, p_state_stripe_x)
            >>> p_state_stripe_y = [[["empty", "empty"]],
            ...                      [["full", "full"]]]
            >>> psi_stripe_y = tenpy.networks.MPS.from_lat_product_state(honeycomb, p_state_stripe_y)
        """
        kwargs.setdefault("bc", lat.bc_MPS)
        p_state = np.array(p_state, dtype=object)
        if p_state.ndim == len(lat.shape):  # == lat.dim + 1
            p_state = to_array(p_state, shape=lat.shape, allow_incommensurate=allow_incommensurate)  # tile to lattice shape
            p_state_flat = p_state[tuple(lat.order.T)]  # "advanced" numpy indexing
        elif p_state.ndim == len(lat.shape) + 1:
            # extra dimension could be from purely 1D array entries
            # make sure this is the case by converting to float
            p_state = np.array(p_state, kwargs.get("dtype", np.float64))
            # tile to lattice shape, ignore last dimension
            p_state = to_array(p_state, shape=lat.shape + (None, ), allow_incommensurate=allow_incommensurate)
            inds = tuple(lat.order.T) + (slice(None), )
            p_state_flat = p_state[inds]  # "advanced" numpy indexing
        else:
            raise ValueError("wrong dimension of `p_state`. Expected {d:d}-dimensional array of "
                             "(string, int, or 1D array)".format(d=lat.dim + 1))
        from ..models.lattice import HelicalLattice
        if isinstance(lat, HelicalLattice):
            order = lat.regular_lattice.order
            for start in range(0, lat.regular_lattice.N_sites, lat.N_sites):
                shifted_inds = tuple(order[start:start + lat.N_sites, :].T)
                if p_state.ndim == len(lat.shape) + 1:
                    shifted_inds = shifted_inds + (slice(None), )
                shifted_p_state_flat = p_state[shifted_inds]
                if not np.all(p_state_flat == shifted_p_state_flat):
                    raise ValueError("`p_state` not translation invariant w.r.t. HelicalLattice")
        return cls.from_product_state(lat.mps_sites(), p_state_flat, **kwargs)

    @classmethod
    def from_product_state(cls,
                           sites,
                           p_state,
                           bc='finite',
                           dtype=np.float64,
                           permute=True,
                           form='B',
                           chargeL=None):
        """Construct a matrix product state from a given product state.

        Parameters
        ----------
        sites : list of :class:`~tenpy.networks.site.Site`
            The sites defining the local Hilbert space.
        p_state : list of {int | str | 1D array}
            Defines the product state to be represented; one entry for each `site` of the MPS.
            An entry of `str` type is translated to an `int` with the help of
            :meth:`~tenpy.networks.site.Site.state_labels`.
            An entry of `int` type represents the physical index of the state to be used.
            An entry which is a 1D array defines the complete wavefunction on that site; this
            allows to make a (local) superposition.
        bc : {'infinite', 'finite', 'segment'}
            MPS boundary conditions. See docstring of :class:`MPS`.
        dtype : type or string
            The data type of the array entries.
        permute : bool
            The :class:`~tenpy.networks.Site` might permute the local basis states if charge
            conservation gets enabled.
            If `permute` is True (default), we permute the given `p_state` locally according to
            each site's :attr:`~tenpy.networks.Site.perm`.
            The `p_state` entries should then always be given as if `conserve=None` in the Site.
        form : (list of) {``'B' | 'A' | 'C' | 'G' | None`` | tuple(float, float)}
            Defines the canonical form. See module doc-string.
            A single choice holds for all of the entries.
        chargeL : charges
            Leg charges at bond 0, which are purely conventional.

        Returns
        -------
        product_mps : :class:`MPS`
            An MPS representing the specified product state.

        Examples
        --------
        Example to get a Neel state for a :class:`~tenpy.models.tf_ising.TFIChain`:

        .. doctest :: MPS.from_product_state

            >>> from tenpy.networks.mps import MPS
            >>> L = 10
            >>> M = tenpy.models.tf_ising.TFIChain({'L': L})
            >>> p_state = ["up", "down"] * (L//2)  # repeats entries L/2 times
            >>> psi = MPS.from_product_state(M.lat.mps_sites(), p_state, bc=M.lat.bc_MPS)

        The meaning of the labels ``"up","down"`` is defined by the :class:`~tenpy.networks.Site`,
        in this example a :class:`~tenpy.networks.site.SpinHalfSite`.

        Extending the example, we can replace the spin in the center with one with arbitrary
        angles ``theta, phi`` in the bloch sphere.
        However, note that you can not write this bloch state (for ``theta != 0, pi``) when
        conserving symmetries, as the two physical basis states correspond to different symmetry
        sectors.

        .. doctest :: MPS.from_product_state

            >>> spin = tenpy.networks.site.SpinHalfSite(conserve=None, sort_charge=False)
            >>> p_state = ["up", "down"] * (L//2)  # repeats entries L/2 times
            >>> theta, phi = np.pi/4, np.pi/6
            >>> bloch_sphere_state = np.array([np.cos(theta/2), np.exp(1.j*phi)*np.sin(theta/2)])
            >>> p_state[L//2] = bloch_sphere_state   # replace one spin in center
            >>> psi = MPS.from_product_state([spin]*L, p_state, bc=M.lat.bc_MPS, dtype=complex)

        Note that for the more general :class:`~tenpy.models.spins.SpinChain`,
        the order of the two entries for the ``bloch_sphere_state`` would be *exactly the opposite*
        (when we keep the the north-pole of the bloch sphere being the up-state).
        The reason is that the `SpinChain` uses the general :class:`~tenpy.networks.site.SpinSite`,
        where the states are ordered ascending from ``'down'`` to ``'up'``.
        The :class:`~tenpy.networks.site.SpinHalfSite` on the other hand uses the order
        ``'up', 'down'`` where that the Pauli matrices look as usual.
        """
        sites = list(sites)
        L = len(sites)
        p_state = list(p_state)
        if len(p_state) != L:
            raise ValueError("Length of p_state does not match number of sites.")
        ci = sites[0].leg.chinfo
        Bs = []
        chargeL = ci.make_valid(chargeL)  # sets to zero if `None`
        legL = npc.LegCharge.from_qflat(ci, [chargeL])  # (no need to bunch)
        for p_st, site in zip(p_state, sites):
            perm = permute
            if isinstance(p_st, str):
                p_st = site.state_labels[p_st]  # translate labels into "int"
                perm = False
            try:
                iter(p_st)
            except TypeError:
                # just an int for p_st
                B = np.zeros((site.dim, 1, 1), dtype)
                B[p_st, 0, 0] = 1.0
            else:  # iter works
                if len(p_st) != site.dim:
                    raise ValueError("p_state incompatible with local dim:" + repr(p_st))
                B = np.array(p_st, dtype).reshape((site.dim, 1, 1))
            if perm:
                B = B[site.perm, :, :]
            Bs.append(B)
        SVs = [[1.]] * (L + 1)
        return cls.from_Bflat(sites, Bs, SVs, bc, dtype, False, form, legL)

    @classmethod
    def from_random_unitary_evolution(cls,
                                      sites,
                                      chi,
                                      p_state,
                                      bc='finite',
                                      dtype=np.float64,
                                      permute=True,
                                      form='B',
                                      chargeL=None):
        psi = MPS.from_product_state(sites,
                                     p_state,
                                     bc,
                                     dtype,
                                     permute,
                                     form,
                                     chargeL)
        tebd_options = dict(N_steps = 10, trunc_params={'chi_max': chi})
        eng = RandomUnitaryEvolution(psi, tebd_options)
        if bc == 'finite':
            while max(psi.chi) < chi:
                eng.run()
        elif bc == 'infinite':
            while np.any(np.array(psi.chi) < chi):
                eng.run()
        else:
            raise NotImplementedError("MPS.from_random_unitary_evolution not implemented for segment BC.")
        logger.info("Generated MPS of bond dimension %r via random evolution.", list(psi.chi))
        psi.canonical_form()
        return psi

    @classmethod
    def from_desired_bond_dimension(cls,
                                    sites,
                                    chis,
                                    bc='finite',
                                    dtype=np.float64,
                                    permute=True,
                                    chargeL=None):
        """Construct a matrix product state with given bond dimensions from random matrices (no charge conservation).

        Parameters
        ----------
        sites : list of :class:`~tenpy.networks.site.Site`
            The sites defining the local Hilbert space.
        chis : (list of) {int}
            Desired bond dimensions. For a single int, the same bond dimension is used on every bond.
        bc : {'infinite', 'finite'}
            MPS boundary conditions. See docstring of :class:`MPS`. For 'finite' chi is capped to the maximum possible at each bond.
        dtype : type or string
            The data type of the array entries.
        permute : bool
            The :class:`~tenpy.networks.Site` might permute the local basis states if charge
            conservation gets enabled.
            If `permute` is True (default), we permute the given `p_state` locally according to
            each site's :attr:`~tenpy.networks.Site.perm`.
            The `p_state` entries should then always be given as if `conserve=None` in the Site.
        chargeL : charges
            Leg charges at bond 0, which are purely conventional.

        Returns
        -------
        mps : :class:`MPS`
            An MPS with the desired bond dimension.
        """
        sites = list(sites)
        L = len(sites)
        # TODO: what happens if we have charge conservation?
        assert sites[0].leg.chinfo.qnumber == 0, "does not work with conserved charges"
        if bc == 'finite':
            if isinstance(chis, int):
                chi_uniform = chis
                chis = [chi_uniform] * (L-1)
            assert len(chis) == L-1, "wrong length of chi list"
            chis.append(1)
            SVs = [np.ones(1)]
            Q, _ = np.linalg.qr(np.random.rand(sites[0].dim, chis[0]))
            Bflat = [Q.reshape(sites[0].dim, 1, Q.shape[1])] # TODO: this only does real entries
            for i in range(1, L-1):
                B_vR = Bflat[-1].shape[2]
                SV = np.random.rand(B_vR)
                SVs.append(SV/np.linalg.norm(SV))
                Q, _ = np.linalg.qr(np.random.rand(sites[i].dim*B_vR, chis[i]))
                Bflat.append(Q.reshape(sites[i].dim, B_vR, Q.shape[1]))
            B_vR = Bflat[-1].shape[2]
            SV = np.random.rand(B_vR)
            SVs.append(SV/np.linalg.norm(SV))
            Bflat.append(np.random.rand(sites[-1].dim*chis[L-2]).reshape(sites[-1].dim, B_vR, 1))
            SVs = [np.ones(1)]
        elif bc == 'infinite':
            if isinstance(chis, int):
                chi_uniform = chis
                chis = [chi_uniform] * L
            assert len(chis) == L, "wrong length of chi list"
            Bflat = []
            SVs = []
            for i in range(L):
                SV = np.random.rand(chis[i])
                SVs.append(SV/np.linalg.norm(SV))
                Q, _ = np.linalg.qr(np.random.rand(sites[i].dim*chis[i], chis[(i+1)%L]))
                Bflat.append(Q.reshape(sites[i].dim, chis[i], chis[(i+1)%L]))
            SVs.append(SVs[0])
        else:
            raise NotImplementedError("MPS.from_desired_bond_dimension not implemented for segment BC.")
        psi = MPS.from_Bflat(sites, Bflat, bc=bc, dtype=dtype, permute=permute, form=None, legL=chargeL)
        psi.canonical_form()
        logger.info("Generated MPS of bond dimension %r from random matrices.", list(psi.chi))
        return psi

    @classmethod
    def from_Bflat(cls,
                   sites,
                   Bflat,
                   SVs=None,
                   bc='finite',
                   dtype=None,
                   permute=True,
                   form='B',
                   legL=None):
        """Construct a matrix product state from a set of numpy arrays `Bflat` and singular vals.

        Parameters
        ----------
        sites : list of :class:`~tenpy.networks.site.Site`
            The sites defining the local Hilbert space.
        Bflat : iterable of numpy ndarrays
            The matrix defining the MPS on each site, with legs ``'p', 'vL', 'vR'``
            (physical, virtual left/right).
        SVs : list of 1D array | ``None``
            The singular values on *each* bond. Should always have length `L+1`.
            By default (``None``), set all singular values to the same value.
            Entries out of :attr:`nontrivial_bonds` are ignored.
        bc : {'infinite', 'finite', 'segment'}
            MPS boundary conditions. See docstring of :class:`MPS`.
        dtype : type or string
            The data type of the array entries. Defaults to the common dtype of `Bflat`.
        permute : bool
            The :class:`~tenpy.networks.Site` might permute the local basis states if charge
            conservation gets enabled.
            If `permute` is True (default), we permute the given `Bflat` locally according to
            each site's :attr:`~tenpy.networks.Site.perm`.
            The `Bflat` should then always be given as if `conserve=None` in the Site.
        form : (list of) {``'B' | 'A' | 'C' | 'G' | None`` | tuple(float, float)}
            Defines the canonical form of `Bflat`. See module doc-string.
            A single choice holds for all of the entries.
        leg_L : LegCharge | ``None``
            Leg charges at bond 0, which are purely conventional.
            If ``None``, use trivial charges.

        Returns
        -------
        mps : :class:`MPS`
            An MPS with the matrices `Bflat` converted to npc arrays.
        """
        sites = list(sites)
        L = len(sites)
        Bflat = list(Bflat)
        if len(Bflat) != L:
            raise ValueError("Length of Bflat does not match number of sites.")
        ci = sites[0].leg.chinfo
        if legL is None:
            legL = npc.LegCharge.from_qflat(ci, [ci.make_valid(None)] * Bflat[0].shape[1])
            legL = legL.bunch()[1]
        if SVs is None:
            SVs = [np.ones(B.shape[1]) / np.sqrt(B.shape[1]) for B in Bflat]
            SVs.append(np.ones(Bflat[-1].shape[2]) / np.sqrt(Bflat[-1].shape[2]))
        Bs = []
        if dtype is None:
            dtype = np.dtype(np.common_type(*Bflat))
        for i, site in enumerate(sites):
            B = np.array(Bflat[i], dtype)
            if permute:
                B = B[site.perm, :, :]
            # calculate the LegCharge of the right leg
            legs = [site.leg, legL, None]  # other legs are known
            legs = npc.detect_legcharge(B, ci, legs, None, qconj=-1)
            B = npc.Array.from_ndarray(B, legs, dtype)
            B.iset_leg_labels(['p', 'vL', 'vR'])
            Bs.append(B)
            legL = legs[-1].conj()  # prepare for next `i`
        if bc == 'infinite':
            # for an iMPS, the last leg has to match the first one.
            # so we need to gauge `qtotal` of the last `B` such that the right leg matches.
            chdiff = Bs[-1].get_leg('vR').charges[0] - Bs[0].get_leg('vL').charges[0]
            Bs[-1] = Bs[-1].gauge_total_charge('vR', ci.make_valid(chdiff))
        res = cls(sites, Bs, SVs, form=form, bc=bc)
        if res.L > 1 and max(res.chi) > 1:
            # the SVs set above are not the correct Schmidt values if chi > 1.
            res.canonical_form()
        return res

    @classmethod
    def from_full(cls,
                  sites,
                  psi,
                  form=None,
                  cutoff=1.e-16,
                  normalize=True,
                  bc='finite',
                  outer_S=None):
        """Construct an MPS from a single tensor `psi` with one leg per physical site.

        Performs a sequence of SVDs of psi to split off the `B` matrices and obtain the singular
        values, the result will be in canonical form.
        Obviously, this is only well-defined for `finite` or `segment` boundary conditions.

        Parameters
        ----------
        sites : list of :class:`~tenpy.networks.site.Site`
            The sites defining the local Hilbert space.
        psi : :class:`~tenpy.linalg.np_conserved.Array`
            The full wave function to be represented as an MPS.
            Should have labels ``'p0', 'p1', ...,  'p{L-1}'``.
            Additionally, it may have (or must have for 'segment' `bc`) the legs ``'vL', 'vR'``,
            which are trivial for 'finite' `bc`.
        form  : ``'B' | 'A' | 'C' | 'G' | None``
            The canonical form of the resulting MPS, see module doc-string.
            ``None`` defaults to 'A' form on the first site and 'B' form on all following sites.
        cutoff : float
            Cutoff of singular values used in the SVDs.
        normalize : bool
            Whether the resulting MPS should have 'norm' 1.
        bc : 'finite' | 'segment'
            Boundary conditions.
        outer_S : None | (array, array)
            For 'segment' `bc` the singular values on the left and right of the considered segment,
            `None` for 'finite' boundary conditions.

        Returns
        -------
        psi_mps : :class:`MPS`
            MPS representation of `psi`, in canonical form and possibly normalized.
        """
        if form is not None and form not in ['B', 'A', 'C', 'G']:
            raise ValueError("Invalid form: " + repr(form))
        if bc != 'finite' and bc != 'segment':
            raise ValueError("Wrong boundary conditions: " + repr(bc))
        # perform SVDs to bring it into 'B' form, afterwards change the form.
        L = len(sites)
        assert (L >= 2)
        B_list = [None] * L
        S_list = [None] * (L + 1)
        norm = 1. if normalize else npc.norm(psi)
        if not psi.has_label('vL'):
            psi = psi.add_trivial_leg(0, label='vL', qconj=+1)
        elif bc == 'finite' and psi.get_leg('vL').ind_len != 1:
            raise ValueError("non-trivial left leg for 'finite' bc!")
        if not psi.has_label('vR'):
            psi = psi.add_trivial_leg(len(psi.get_leg_labels()), label='vR', qconj=-1)
        elif bc == 'finite' and psi.get_leg('vR').ind_len != 1:
            raise ValueError("non-trivial left leg for 'finite' bc!")
        labels = ['vL'] + ['p' + str(i) for i in range(L)] + ['vR']
        psi.itranspose(labels)
        # combine legs from left
        for i in range(0, L - 1):
            psi = psi.combine_legs([0, 1])  # combines the legs until `i`
        # now psi has only three legs: ``'(((vL.p0).p1)...p{L-2})', 'p{L-1}', 'vR'``
        for i in range(L - 1, 0, -1):
            # split off B[i]
            psi = psi.combine_legs([labels[i + 1], 'vR'])
            psi, S, B = npc.svd(psi, inner_labels=['vR', 'vL'], cutoff=cutoff)
            S /= np.linalg.norm(S)  # normalize
            if i > 1:
                psi.iscale_axis(S, 1)
            B_list[i] = B.split_legs(1).replace_label(labels[i + 1], 'p')
            S_list[i] = S
            psi = psi.split_legs(0)
        # psi is now the first `B` in 'A' form
        B_list[0] = psi.replace_label(labels[1], 'p')
        B_form = ['A'] + ['B'] * (L - 1)
        if bc == 'finite':
            S_list[0] = S_list[-1] = np.ones([1], dtype=np.float64)
        elif outer_S is not None:
            S_list[0], S_list[-1] = outer_S
        res = cls(sites, B_list, S_list, bc=bc, form=B_form, norm=norm)
        if form is not None:
            res.convert_form(form)
        return res

    @classmethod
    def from_singlets(cls,
                      site,
                      L,
                      pairs,
                      up='up',
                      down='down',
                      lonely=[],
                      lonely_state='up',
                      bc='finite'):
        """Create an MPS of entangled singlets.

        Parameters
        ----------
        site : :class:`~tenpy.networks.site.Site`
            The `site` defining the local Hilbert space, taken uniformly for all sites.
        L : int
            The number of sites.
        pairs : list of (int, int)
            Pairs of sites to be entangled; the returned MPS will have a singlet
            for each pair in `pairs`. For ``bc='infinite'`` MPS, some indices can be outside
            the range [0, L) to indicate couplings across infinite MPS unit cells.
        up, down : int | str
            A singlet is defined as ``(|up down> - |down up>)/2**0.5``,
            ``up`` and ``down`` give state indices or labels defined on the corresponding site.
        lonely : list of int
            Sites which are not included into a singlet pair.
        lonely_state : int | str
            The state for the lonely sites.
        bc : {'infinite', 'finite', 'segment'}
            MPS boundary conditions. See docstring of :class:`MPS`.

        Returns
        -------
        singlet_mps : :class:`MPS`
            An MPS representing singlets on the specified pairs of sites.
        """
        assert 2 * len(pairs) + len(lonely) == L, "incompatible indices"
        psi_up_down = MPS.from_product_state([site]* 2, [up, down])
        psi_down_up = MPS.from_product_state([site]* 2, [down, up])
        psi_singlet = psi_up_down.add(psi_down_up, 0.5**0.5, -0.5**0.5)
        mps_covering = [psi_singlet]*len(pairs)
        index_map = list(pairs)
        if len(lonely) > 0:
            psi_lonely = MPS.from_product_state([site], [lonely_state])
            mps_covering.extend([psi_lonely] * len(lonely))
            index_map.extend([(i, ) for i in lonely])
        psi = cls.from_product_mps_covering(mps_covering, index_map, bc=bc)
        assert psi.L == L
        return psi

    @classmethod
    def from_product_mps_covering(cls, mps_covering, index_map, bc='finite'):
        """Create an MPS as a product of (many) local mps covering all sites to be created.

        This is a generalization of :meth:`from_singlets` to allow arbitrary local, entangled
        states over multiple sites. Those local states are represented by MPS in `mps_covering`,
        such that each site in the final MPS gets it state from exactly one local MPS.

        For example to reproduce :meth:`from_singlets`,
        you define L/2 local two-site mps in a singlet state, and use the `pairs` as `index_map`.
        (If you have `lonely` states not entangled into a singlet, add a trivial one-site MPS
        for them as well.) Indeed, if you look into the source code of :meth:`from_singlets`,
        this is exactly what it does (at least since this method was implemented).

        More generally, you can easily initialize any kind of valence bond solid state, if you
        just initialize the corresponding local states and generate a corresponding `index_map`
        of the geometry of pairs, see the example below.

        Parameters
        ----------
        mps_covering : list of :class:`MPS`
            List of local, 'finite' MPS.
        index_map : list of tuple of int
            For each `local_psi` in `mps_covering`, add one tuple with ``local_psi.L`` entries
            which sites in the returned `psi` should

        Returns
        -------
        psi : :class:`MPS`
            An MPS constructed as explained above.

        Example
        -------
        Say you have three local MPS with ``mps_covering = [psi_A, psi_B, psi_C]``
        with `A`, `B` and `C` tensors on 3, 2, and 2 sites, respectively.
        Using the ``index_map=[[0, 1, 3], [2, 5], [4, 6]]`` would combine them as::

            |    A0-A1----A2 C0----C1
            |    |  |     |  |     |
            |    |  |  B0-|--|--B1 |
            |    |  |  |  |  |  |  |
            |    0  1  2  3  4  5  6

        Using the ``index_map=[[1, 2, 0], [3, 5], [6, 4]]`` would rather combine them as::

            |    A2----.     C1----C0
            |    |     |     |     |
            |    |  A0-A1 B0-|--B1 |
            |    |  |  |  |  |  |  |
            |    0  1  2  3  4  5  6

        As another example, let's generalize :meth:`from_singlets` to "spin-full" fermions
        represented by the (spin-less!) :class:`~tenpy.networks.site.FermionSite` with an extra
        index for the spin, here `u=0,1` on a 2D square lattice.

        .. testsetup :: product_mps_covering

            from tenpy.networks.mps import MPS
            from tenpy.networks.site import FermionSite
            from tenpy.models.lattice import Square, MultiSpeciesLattice

        .. doctest :: product_mps_covering

            >>> ferm = FermionSite(conserve='N')
            >>> lat = MultiSpeciesLattice(Square(4, 2, None), [ferm]*2, ['up', 'down'])
            >>> ferm_up_down = MPS.from_product_state([ferm]*4, ['full', 'empty', 'empty', 'full'])
            >>> ferm_down_up = MPS.from_product_state([ferm]*4, ['empty', 'full', 'full', 'empty'])
            >>> ferm_singlet = ferm_up_down.add(ferm_down_up, 0.5**0.5, -0.5**0.5)
            >>> index_map = [[(x, y, 0), (x, y, 1), (x+1, y, 0), (x+1, y, 1)]
            ...    for (x, y) in [(0, 0), (0, 1), (2, 0), (2, 1)]]
            >>> index_map = [[lat.lat2mps_idx(x_y_u) for x_y_u in pairs] for pairs in index_map]
            >>> psi = MPS.from_product_mps_covering([ferm_singlet]*4, index_map)

        This will generate a singlet valence bold solid (VBS) state looking like this::

            |    x--x  x--x
            |
            |    x--x  x--x

        """
        assert len(mps_covering) == len(index_map)
        L = sum([len(x) for x in index_map])
        sites = [None] * L
        for local_psi, ind_map in zip(mps_covering, index_map):
            assert local_psi.bc == 'finite'
            for site, i in zip(local_psi.sites, ind_map):
                if sites[i % L] is not None:
                    raise ValueError(f"duplicate index {i:d} for {L:d}-site index_map\n{index_map!r}")
                sites[i % L] = site
        chinfo = sites[0].leg.chinfo
        for site in sites:
            assert site.leg.chinfo == chinfo, "incompatible types of charges"
        # first extract tensors from local mps
        # i = index in new psi to be constructed, j = index in local_psi
        B_parts = [[] for _ in range(L)]
        SR_parts = [[] for _ in range(L)]
        for local_psi, ind_map in zip(mps_covering, index_map):
            local_psi = local_psi.copy()
            argsort = np.argsort(ind_map)
            if not np.all(argsort == np.arange(len(argsort))):
                local_psi.permute_sites(argsort)
                ind_map = [ind_map[i] for i in argsort]
            local_psi.convert_form('B')
            triv_leg = npc.LegCharge(chinfo, [0, 1], [chinfo.make_valid()])  # trivial leg
            local_psi.gauge_total_charge(vL_leg=triv_leg, vR_leg=triv_leg.conj())
            for j, i in enumerate(ind_map):
                B = local_psi.get_B(j, 'B')
                B_parts[i % L].append(B)
                SR = local_psi.get_SR(j)
                SR_parts[i % L].append(SR)
                if j + 1 < len(ind_map):
                    next_i = ind_map[j + 1]
                    vR_leg = B.get_leg('vR')
                    Triv = npc.diag(1., vR_leg.conj(), labels=['vL', 'vR'])
                    for i2 in range(i + 1, next_i):
                        B_parts[i2 % L].append(Triv)
                        SR_parts[i2 % L].append(SR)
        # combine B_parts and SR_parts to big tensors Bs and SVs
        Bs = []
        SVs = [None]
        for B_p, S_p in zip(B_parts, SR_parts):
            B = B_p[0]
            SR = S_p[0]
            for B2, SR2 in zip(B_p[1:], S_p[1:]):
                B2 = B2.replace_labels(['vL', 'vR'], ['vL2', 'vR2'])
                B = npc.outer(B, B2).combine_legs([['vL', 'vL2'], ['vR', 'vR2']], qconj=[+1, -1])
                B.ireplace_labels(['(vL.vL2)', '(vR.vR2)'], ['vL', 'vR'])
                pipeR = B.get_leg('vR')
                d, d2 = (len(SR), len(SR2))
                inds = np.indices([d, d2]).transpose([1, 2, 0]).reshape([d*d2, 2])
                SR = SR[inds[:, 0]] * SR2[inds[:, 1]] # = np.outer(SR, SR2).flatten()
                perm = [pipeR.map_incoming_flat(ind) for ind in inds]
                SR = SR[inverse_permutation(perm)]
                B.legs[B.get_leg_index('vR')] = pipeR.to_LegCharge()
                B.legs[B.get_leg_index('vL')] = B.get_leg('vL').to_LegCharge()
            Bs.append(B)
            SVs.append(SR)
        SVs[0] = SVs[-1]
        return cls(sites, Bs, SVs, bc=bc, form='B')

    @property
    def L(self):
        """Number of physical sites; for an iMPS the len of the MPS unit cell."""
        return len(self.sites)

    @property
    def dim(self):
        """List of local physical dimensions."""
        return [site.dim for site in self.sites]

    @property
    def finite(self):
        """Distinguish MPS vs iMPS.

        True for an MPS (``bc='finite', 'segment'``), False for an iMPS (``bc='infinite'``).
        """
        assert (self.bc in self._valid_bc)
        return self.bc != 'infinite'

    @property
    def chi(self):
        """Dimensions of the (nontrivial) virtual bonds."""
        # s.shape[0] == len(s) for 1D numpy array, but works also for a 2D npc Array.
        return [min(s.shape) for s in self._S[self.nontrivial_bonds]]

    @property
    def nontrivial_bonds(self):
        """Slice of the non-trivial bond indices, depending on ``self.bc``."""
        if self.bc == 'finite':
            return slice(1, self.L)
        elif self.bc == 'segment':
            return slice(0, self.L + 1)
        elif self.bc == 'infinite':
            return slice(0, self.L)

    def get_B(self, i, form='B', copy=False, cutoff=1.e-16, label_p=None):
        """Return (view of) `B` at site `i` in canonical form.

        Parameters
        ----------
        i : int
            Index choosing the site.
        form : ``'B' | 'A' | 'C' | 'G' | 'Th' | None`` | tuple(float, float)
            The (canonical) form of the returned B.
            For ``None``, return the matrix in whatever form it is.
            If any of the tuple entry is None, also don't scale on the corresponding axis.
        copy : bool
            Whether to return a copy even if `form` matches the current form.
        cutoff : float
            During DMRG with a mixer, `S` may be a matrix for which we need the inverse.
            This is calculated as the Penrose pseudo-inverse, which uses a cutoff for the
            singular values.
        label_p : None | str
            Ignored by default (``None``).
            Otherwise replace the physical label ``'p'`` with ``'p'+label_p'``.
            (For derived classes with more than one "physical" leg, replace all the physical leg
            labels accordingly.)

        Returns
        -------
        B : :class:`~tenpy.linalg.np_conserved.Array`
            The MPS 'matrix' `B` at site `i` with leg labels ``'vL', 'p', 'vR'``.
            May be a view of the matrix (if ``copy=False``),
            or a copy (if the form changed or ``copy=True``).

        Raises
        ------
        ValueError : if self is not in canonical form and `form` is not None.
        """
        i = self._to_valid_index(i)
        new_form = self._to_valid_form(form)
        old_form = self.form[i]
        B = self._B[i]
        if copy:
            B = B.copy()
        if new_form is not None and old_form != new_form:
            if old_form is None:
                raise ValueError("can't convert form of non-canonical state!")
            if new_form[0] is not None and new_form[0] - old_form[0] != 0.:
                B = self._scale_axis_B(B, self.get_SL(i), new_form[0] - old_form[0], 'vL', cutoff)
            if new_form[1] is not None and new_form[1] - old_form[1] != 0.:
                B = self._scale_axis_B(B, self.get_SR(i), new_form[1] - old_form[1], 'vR', cutoff)
        if label_p is not None:
            B = self._replace_p_label(B, label_p)
        return B

    def set_B(self, i, B, form='B'):
        """Set `B` at site `i`.

        Parameters
        ----------
        i : int
            Index choosing the site.
        B : :class:`~tenpy.linalg.np_conserved.Array`
            The 'matrix' at site `i`. No copy is made!
            Should have leg labels ``'vL', 'p', 'vR'`` (not necessarily in that order).
        form : ``'B' | 'A' | 'C' | 'G' | 'Th' | None`` | tuple(float, float)
            The (canonical) form of the `B` to set.
            ``None`` stands for non-canonical form.
        """
        i = self._to_valid_index(i)
        self.form[i] = self._to_valid_form(form)
        self.dtype = np.promote_types(self.dtype, B.dtype)
        self._B[i] = B.itranspose(self._B_labels)

    def set_svd_theta(self, i, theta, trunc_par=None, update_norm=False):
        """SVD a two-site wave function `theta` and save it in `self`.

        Parameters
        ----------
        i : int
            `theta` is the wave function on sites `i`, `i` + 1.
        theta : :class:`~tenpy.linalg.np_conserved.Array`
            The two-site wave function with labels combined into ``"(vL.p0)", "(p1.vR)"``,
            ready for svd.
        trunc_par : None | dict
            Parameters for truncation, see :cfg:config:`truncation`.
            If ``None``, no truncation is done.
        update_norm : bool
            If ``True``, multiply the norm of `theta` into :attr:`norm`.
        """
        i0 = self._to_valid_index(i)
        i1 = self._to_valid_index(i0 + 1)
        self.dtype = np.promote_types(self.dtype, theta.dtype)
        qtotal_LR = [self._B[i0].qtotal, None]
        if trunc_par is None:
            U, S, VH = npc.svd(theta, qtotal_LR=qtotal_LR, inner_labels=['vR', 'vL'])
            renorm = np.linalg.norm(S)
            S /= renorm
            err = None
            if update_norm:
                self.norm *= renorm
        else:
            U, S, VH, err, renorm = svd_theta(theta, trunc_par, qtotal_LR)
            if update_norm:
                self.norm *= renorm
        U = U.split_legs().ireplace_label('p0', 'p')
        VH = VH.split_legs().ireplace_label('p1', 'p')
        self._B[i0] = U.itranspose(self._B_labels)
        self.form[i0] = self._valid_forms['A']
        self._B[i1] = VH.itranspose(self._B_labels)
        self.form[i1] = self._valid_forms['B']
        self.set_SR(i, S)
        return err

    def get_SL(self, i):
        """Return singular values on the left of site `i`"""
        i = self._to_valid_index(i)
        return self._S[i]

    def get_SR(self, i):
        """Return singular values on the right of site `i`"""
        i = self._to_valid_index(i)
        return self._S[i + 1]

    def set_SL(self, i, S):
        """Set singular values on the left of site `i`"""
        i = self._to_valid_index(i)
        self._S[i] = S
        if not self.finite and i == 0:
            self._S[self.L] = S

    def set_SR(self, i, S):
        """Set singular values on the right of site `i`"""
        i = self._to_valid_index(i)
        self._S[i + 1] = S
        if not self.finite and i == self.L - 1:
            self._S[0] = S

    def get_theta(self, i, n=2, cutoff=1.e-16, formL=1., formR=1.):
        """Calculates the `n`-site wavefunction on ``sites[i:i+n]``.

        Parameters
        ----------
        i : int
            Site index.
        n : int
            Number of sites. The result lives on ``sites[i:i+n]``.
        cutoff : float
            During DMRG with a mixer, `S` may be a matrix for which we need the inverse.
            This is calculated as the Penrose pseudo-inverse, which uses a cutoff for the
            singular values.
        formL : float
            Exponent for the singular values to the left.
        formR : float
            Exponent for the singular values to the right.

        Returns
        -------
        theta : :class:`~tenpy.linalg.np_conserved.Array`
            The n-site wave function with leg labels ``vL, p0, p1, .... p{n-1}, vR``.
            In Vidal's notation (with s=lambda, G=Gamma):
            ``theta = s**form_L G_i s G_{i+1} s ... G_{i+n-1} s**form_R``.
        """
        i = self._to_valid_index(i)
        for j in range(i, i + n):
            if self.form[j % self.L] is None:
                raise ValueError("can't calculate theta for non-canonical form")
        if n == 1:
            return self.get_B(i, (1., 1.), True, cutoff, '0')
        elif n < 1:
            raise ValueError("n needs to be larger than 0")
        # n >= 2: contract some B's
        theta = self.get_B(i, (formL, None), False, cutoff, '0')  # right form as stored
        _, old_fR = self.form[i]
        for k in range(1, n):  # non-empty range
            j = self._to_valid_index(i + k)
            new_fR = None if k + 1 < n else formR  # right form as stored, except for last B
            B = self.get_B(j, (1. - old_fR, new_fR), False, cutoff, str(k))
            _, old_fR = self.form[j]
            theta = npc.tensordot(theta, B, axes=['vR', 'vL'])
        return theta

    def convert_form(self, new_form='B'):
        """Transform self into different canonical form (by scaling the legs with singular values).

        Parameters
        ----------
        new_form : (list of) {``'B' | 'A' | 'C' | 'G' | 'Th' | None`` | tuple(float, float)}
            The form the stored 'matrices'. The table in module doc-string.
            A single choice holds for all of the entries.

        Raises
        ------
        ValueError : if trying to convert from a ``None`` form. Use :meth:`canonical_form` instead!
        """
        new_forms = self._parse_form(new_form)
        for i, new_form in enumerate(new_forms):
            new_B = self.get_B(i, form=new_form, copy=False)  # calculates the desired form.
            self.set_B(i, new_B, form=new_form)

    def increase_L(self, new_L=None):
        """Modify `self` inplace to enlarge the MPS unit cell.

        .. deprecated :: 0.5.1
            This method will be removed in version 1.0.0.
            Use the equivalent ``psi.enlarge_mps_unit_cell(new_L//psi.L)`` instead of
            ``psi.increase_L(new_L)``.

        Parameters
        ----------
        new_L : int
            New number of sites. Needs to be an integer multiple of :attr:`L`.
            Defaults to ``2*self.L``.
        """
        old_L = self.L
        if new_L is None:
            new_L = 2 * old_L
        if new_L % old_L:
            raise ValueError("new_L = {0:d} not a multiple of old L={1:d}".format(new_L, old_L))
        factor = new_L // old_L
        warnings.warn(
            "use `psi.enlarge_mps_unit_cell(factor=new_L//psi.L)` "
            "instead of `psi.increase_L(new_L)`.", FutureWarning, 2)
        self.enlarge_mps_unit_cell(factor)

    def enlarge_mps_unit_cell(self, factor=2):
        """Repeat the unit cell for infinite MPS boundary conditions; in place.

        Parameters
        ----------
        factor : int
            The new number of sites in the unit cell will be increased from `L` to ``factor*L``.
        """
        if int(factor) != factor:
            raise ValueError("`factor` should be integer!")
        if factor <= 1:
            raise ValueError("can't shrink!")
        if self.bc == 'segment':
            raise ValueError("can't enlarge segment MPS")
        self.sites = factor * self.sites
        self._B = factor * self._B
        self._S = factor * self._S[:-1] + [self._S[-1]]
        self.form = factor * self.form
        self.test_sanity()

    def roll_mps_unit_cell(self, shift=1):
        """Shift the section we define as unit cell of an infinite MPS; in place.

        Suppose we have a unit cell with tensors ``[A, B, C, D]`` (repeated on both sites).
        With ``shift = 1``, the new unit cell will be ``[D, A, B, C]``,
        whereas ``shift = -1`` will give ``[B, C, D, A]``.

        Parameters
        ----------
        shift : int
            By how many sites to move the tensors to the right.
        """
        if self.finite:
            raise ValueError("makes only sense for infinite boundary conditions")
        inds = np.roll(np.arange(self.L), shift)
        self.sites = [self.sites[i] for i in inds]
        self.form = [self.form[i] for i in inds]
        self._B = [self._B[i] for i in inds]
        self._S = [self._S[i] for i in inds]
        self._S.append(self._S[0])

    def overlap_translate_finite(self, psi, shift=1):
        r"""Contract ``<self|T^N|psi>`` for translation `T` with finite, periodic boundaries.

        Looks like this for ``shift=1``, with the open virtual legs contracted in the end::

           --B[L-1] Th[0] -- B[1] -- B[2] -- ..... B[L-2] --
              |      |       |       |             |
            Th*[0] --B*[1] --B*[2] --B*[3] --..... B*[L-1]


        An alternative to calling this method would be to call :meth:`permute_sites` followed by
        :meth:`overlap`. Note that `permute_sites` uses truncation on the way, though,
        which could severely affect the precision especially for general (non-local)
        permutations while this function contracts everything exactly
        (possibly at higher numerical cost).

        Parameters
        ----------
        psi : :class:`MPS`
            MPS to take overlap with.
        shift : int
            Translation by how many sites. Note that for large shift, the contraction is
            :math:`O(\chi^4)` compared to DMRG etc scaling as :math:`O(\chi^3)`.

        Returns
        -------
        self_Tn_psi : float
            Contraction of ``<self|T^N|psi>``.

        See also
        --------
        permute_sites : Allows more general permutations of the sites.
        overlap : Directly the overlap between two MPS without translation.
        roll_mps_unit_cell : Effectively applies ``T^shift`` on infinite MPS.
        """
        assert self.bc == psi.bc == 'finite'
        L = self.L
        assert L == psi.L
        if shift < 0:
            shift = shift + self.L
        assert 0 < shift < self.L
        forms = ['Th'] + ['B'] * (L-1)
        inds = np.roll(np.arange(self.L), shift)  # consistent with `roll_mps_unit_cell`!
        B_bra = self.get_B(0, forms[0])
        B_ket = psi.get_B(inds[0], forms[inds[0]])
        C = npc.tensordot(B_bra.conj(), B_ket, axes=[self._get_p_label('*'), self._get_p_label('')])
        for i in range(1, L):
            j = inds[i]
            B_ket = psi.get_B(j, forms[j])
            if i != shift:
                C = npc.tensordot(C, B_ket, axes=['vR', 'vL'])
            else:
                # here, B_ket is the Th[0] - handle the open left/rightmost, trivial virtual legs
                C.ireplace_label('vR', 'openR')
                C = npc.tensordot(C, B_ket, axes=['vL*', 'vL'])  # contract trivial left legs
            B_bra = self.get_B(i, forms[i])
            C = npc.tensordot(C, B_bra.conj(), axes=[['vR*'] + self._get_p_label(''),
                                                     ['vL*'] + self._get_p_label('*')])
        return npc.trace(npc.trace(C, 'vR', 'vL'), 'openR', 'vR*')

    def enlarge_chi(self, extra_legs, random_fct=np.random.normal):
        """Artificially enlarge the bond dimension by the specified extra legs/charges. In place.

        First converts the MPS in B form.
        This function then fills up the 'vR' leg with zeros, and then groups physical and vR legs
        to fill up the 'vL' leg with orthogonal rows. In than way, we get an MPS with larger bond
        dimension, still in right-canonical form (assuming no "overcomplete" charge block),
        representing the *same* state, with the additional singular values being exactly zero.

        .. note ::
            You should probably **choose** the extra charges to be sensible,
            to expand into the space you are interested in, and not just into a random direction!

        Parameters
        ----------
        extra_legs : list of {None, :class:`~tenpy.linalg.charges.LegCharge`, int}
            The extra charges to be added on the virtual legs, with qconj=+1.
            Length `L` +1 for finite, length `L` for infinite, with entry `i` left of site `i`.
            If an `int` is given, fill up with a single block of charges like the Schmidt state
            with highest weight. Note that this might force the resulting state to not be in
            strict "right-canonical" B form if that charge block becomes overcomplete.
        random_fct :
            Function generating random entries to choose extra orthogonal rows in the B tensors.
            Should accept a `size` keyword for the shape, and return numpy arrays.

        Returns
        -------
        permutations: list of 1D array | None
            Permutation performed on each virtual leg, such that
            ``new_S = concatenate(old_S, zeros)[perm]``.
        """
        self.convert_form('B')
        if len(extra_legs) != self.L + (1 if self.finite else 0):
            raise ValueError("wrong len of extra_legs.")
        perms_L = [None] * (self.L + 1)
        perms_R = [None] * (self.L + 1)
        extra_legs = list(extra_legs)
        for i, add_chi in enumerate(extra_legs):
            if not isinstance(add_chi, int):
                continue
            # convert chi to extra LegCharge
            if add_chi == 0:
                extra_legs[i] = None
            elif self.chinfo.qnumber == 0:
                extra_legs[i] = npc.LegCharge.from_trivial(add_chi, self.chinfo)
            else:
                max_weight = np.argmax(self._S[i])
                if i < self.L:
                    leg = self._B[i].get_leg('vL')
                else:
                    leg = self._B[-1].get_leg('vR')
                extra_charge = leg.get_charge(leg.get_qindex(max_weight)[0])[np.newaxis, :]
                extra_legs[i] = npc.LegCharge.from_qind(self.chinfo, [0, add_chi], extra_charge)
        if not self.finite:
            extra_legs.append(extra_legs[0])  # ensure length L+1
        for i, B in enumerate(self._B):
            extra_leg_L = extra_legs[i]
            extra_leg_R = extra_legs[i + 1]
            B.itranspose(self._B_labels)
            if extra_leg_R is not None:
                # add extra zero columns on the vR leg and sort by charges
                extra_leg_R = extra_leg_R.conj()
                B2 = B.extend('vR', extra_leg_R)
                sort = [False] * (len(self._B_labels) - 1) + [True]
                (_, _, perm_R), B2 = B2.sort_legcharge(sort, sort)
                perms_R[i + 1] = perm_R
            else:
                B2 = B
            B2 = B2.combine_legs(self._p_label + ['vR'], qconj=-1, new_axes=1)
            if extra_leg_L is not None:
                p_vR = B2.legs[1]
                # get a new extra block of random entries for the vL leg
                extra_B = npc.Array.from_func(random_fct, [extra_leg_L, p_vR],
                                              dtype=B2.dtype,
                                              qtotal=B2.qtotal,
                                              shape_kw="size")
                # orthogonalize rows of extra_B against rows of B2
                extra_B = extra_B - npc.tensordot(npc.tensordot(extra_B, B2.conj(), [1, 1]),
                                                B2,
                                                [1, 0])
                if npc.norm(extra_B) < 1e-12:
                    logger.warning(
                        f'Failed to orthogonalize extra_B against B2. norm(extra_B) = {npc.norm(extra_B)}.'
                    )
                # orthogonalize rows within extra_B by QR
                extra_B, extra_R = npc.qr(extra_B.itranspose([1, 0]),
                                          inner_qconj=-1,
                                          qtotal_Q=extra_B.qtotal)
                try:
                    extra_B.legs[1].test_equal(extra_R.legs[1])
                except ValueError as e:
                    print(extra_R)
                    raise ValueError("QR for Gram-Schmidt messed up charges. "
                                     "Incompatible charges?") from e
                extra_B.itranspose([1, 0])
                # append extra block in vL leg of B2 and sort by charges
                new_B = npc.concatenate([B2, extra_B], axis='vL')
                (perm_L, _), new_B = new_B.sort_legcharge([True, False], [True, False])
                perms_L[i] = perm_L
            else:
                new_B = B2
            new_B = new_B.split_legs().itranspose(self._B_labels)
            self._B[i] = new_B
        if self.finite:
            # fix undefined permutations at boundaries
            perms_R[0] = perms_L[0]
            perms_L[-1] = perms_R[-1]
        else:
            perms_L[-1] = perms_L[0]
            perms_R[0] = perms_R[-1]
        for perm_L, perm_R in zip(perms_L, perms_R):
            assert (perm_L is not None) == (perm_R is not None)
            if perm_L is not None:
                assert np.all(perm_L == perm_R)
        # append zeros to singular values
        for i, S in enumerate(self._S):
            leg = extra_legs[i]
            if leg is not None:
                new_S = np.concatenate([S, np.zeros(leg.ind_len)])
                assert perms_L[i] is not None
                new_S = new_S[perms_L[i]]
                self._S[i] = new_S
        self.test_sanity()
        return perms_L

    def spatial_inversion(self):
        """Perform a spatial inversion along the MPS.

        Exchanges the first with the last tensor and so on,
        i.e., exchange site `i` with site ``L-1 - i``.
        This is equivalent to a mirror/reflection with the bond left of L/2 (even L) or the site
        (L-1)/2 (odd L) as a fixpoint.
        For infinite MPS, the bond between MPS unit cells is another fix point.
        """
        self.sites = self.sites[::-1]
        self.form = [(f if f is None else (f[1], f[0])) for f in self.form[::-1]]
        self._B = [
            B.replace_labels(['vL', 'vR'], ['vR', 'vL']).transpose(self._B_labels)
            for B in self._B[::-1]
        ]
        self._S = self._S[::-1]
        self.test_sanity()
        return self

    def group_sites(self, n=2, grouped_sites=None):
        """Modify `self` inplace to group sites.

        Group each `n` sites together using the :class:`~tenpy.networks.site.GroupedSite`.
        This might allow to do TEBD with a Trotter decomposition,
        or help the convergence of DMRG (in case of too long range interactions).

        Parameters
        ----------
        n : int
            Number of sites to be grouped together.
        grouped_sites : None | list of :class:`~tenpy.networks.site.GroupedSite`
            The sites grouped together.

        See also
        --------
        group_split : Reverts the grouping.
        """
        self.convert_form('B')
        if grouped_sites is None:
            grouped_sites = group_sites(self.sites, n, charges='same')
        else:
            assert grouped_sites[0].n_sites == n
        Bs = []
        Ss = []
        i = 0
        B_form = self._valid_forms['B']
        for gs in grouped_sites:
            n_sites = gs.n_sites
            new_B = self.get_theta(i, gs.n_sites, formL=B_form[0], formR=B_form[1])
            comb_legs = [[lbl + str(k) for k in range(n_sites)] for lbl in self._p_label]
            # comb_legs = [['p0', 'p1', ... ]] for usual MPS
            axes = list(range(1, 1 + len(self._p_label)))  # [1]
            new_B = new_B.combine_legs(comb_legs, new_axes=axes, qconj=[+1] * len(axes))
            new_B.legs[1].test_equal(gs.leg)  # test legcharge compatibility
            Bs.append(new_B.iset_leg_labels(self._B_labels))  # ['vL', 'p', 'vR']
            Ss.append(self._S[i])
            i += n_sites
        Ss.append(self._S[-1])  # right-most singular values: need L+1 entries
        self._B = Bs
        self._S = Ss
        self.sites = grouped_sites
        self.form = [B_form] * len(grouped_sites)
        self.grouped = self.grouped * n

    def group_split(self, trunc_par=None):
        """Modify `self` inplace to split previously grouped sites.

        Parameters
        ----------
        trunc_par : dict
            Parameters for truncation, see :cfg:config:`truncation`.
            Defaults to ``{'chi_max': max(self.chi)}``.

        Returns
        -------
        trunc_err : :class:`~tenpy.algorithms.truncation.TruncationError`
            The error introduced by the truncation for the splitting.

        See also
        --------
        group_sites : Should have been used before to combine sites.
        """
        if trunc_par is None:
            trunc_par = {}
        trunc_par = asConfig(trunc_par, 'trunc_params')
        self.convert_form('B')
        if self.L > 1:
            trunc_par.setdefault('chi_max', max(self.chi))
        n0 = self.sites[0].n_sites
        sites = []
        Bs = []
        Ss = []
        trunc_err = TruncationError()
        for i, gs in enumerate(self.sites):
            sites.extend(gs.sites)
            n = gs.n_sites
            Ss_new = []
            Bs_new = []
            B_gr = self.get_B(i, form='B').transpose(self._B_labels)  # vL, p, vR
            B_gr.idrop_labels(self._p_label)  # avoid warning: split label not called '(...)'
            n_p_label = len(self._p_label)
            split_legs = list(range(1, 1 + n_p_label))
            transp = [i for k in range(n) for i in range(1 + k, 1 + n * n_p_label, n)]
            transp = ['vL'] + transp + ['vR']
            B_gr = B_gr.split_legs(split_legs).itranspose(transp)
            theta = self.get_theta(i, n=1)
            theta.idrop_labels(self._get_p_label('0'))  # avoid warning
            theta = theta.split_legs(split_legs).itranspose(transp)
            # for usual MPS, B_gr and theta have legs vL p0 p1 ... p{n-1} vR
            # for MPS with legs p, q, they have legs vL p0 q0 p1 q1 ... q{-n-1} vR
            combine = [list(range(B_gr.rank - n_p_label - 1)), list(range(-n_p_label - 1, 0, +1))]
            # combine = [[0, 1, .... {n-1}], [-2, -1]] for usual MPS
            axes_contr = [combine[1], list(range(1, 2 + n_p_label))]
            for j in range(n - 1, 0, -1):
                # split off the right-most physical leg and vR from theta
                # theta: vL p0 ... pj vR
                theta = theta.combine_legs(combine, qconj=[+1, -1])
                U, S, V, err, _ = svd_theta(theta, trunc_par, inner_labels=['vR', 'vL'])
                Ss_new.append(S)
                trunc_err += err
                theta = U.scale_axis(S, 'vR').split_legs(0)  # vL p0 ... pj-1 vR
                for _ in range(n_p_label):
                    combine[0].pop()
                B = V.split_legs(1).iset_leg_labels(self._B_labels)  # vL p vR
                B_gr = npc.tensordot(B_gr, B.conj(), axes=axes_contr)  # vL p0 ... pj-1 vR
                Bs_new.append(B)
            Bs_new.append(B_gr.iset_leg_labels(self._B_labels))  # inversion free :)
            Ss_new.append(self.get_SL(i))
            Bs.extend(Bs_new[::-1])
            Ss.extend(Ss_new[::-1])
        Ss.append(self._S[-1])
        self.sites = sites
        self._B = Bs
        self._S = Ss
        self.grouped = max(self.grouped // n0, 1)
        self.form = [self._valid_forms['B']] * len(sites)
        self.test_sanity()
        return trunc_err

    def get_grouped_mps(self, blocklen):
        r"""Like :meth:`group_sites`, but make a copy.

        Parameters
        ----------
        blocklen: int
            Number of subsequent sites to be combined; `n` in :meth:`group_sites`.

        Returns
        -------
        grouped_MPS :
            New MPS object with bunched sites.
        """
        groupedMPS = self.copy()
        groupedMPS.group_sites(n=blocklen)
        return groupedMPS

    def extract_segment(self, first, last):
        """Extract an segment from a finite or infinite MPS.

        Parameters
        ----------
        first, last : int
            The first and last site to *include* into the segment.

        Returns
        -------
        psi_segment : :class:`MPS`
            Copy of self with 'segment' boundary conditions.
        """
        L = self.L
        sites = [self.sites[i % L] for i in range(first, last + 1)]
        B = [self.get_B(i) for i in range(first, last + 1)]
        S = [self.get_SL(i) for i in range(first, last + 1)]
        S.append(self.get_SR(last))
        # note: __init__ makes deep copies of B, S
        cp = self.__class__(sites, B, S, 'segment', 'B', self.norm)
        cp.grouped = self.grouped
        if self.bc == 'segment':
            U_L, V_R = self.segment_boundaries
            if U_L is not None or V_R is not None:
                if first != 0:
                    U_L = None
                if last != self.L - 1:
                    V_R = None
            if U_L is not None or V_R is not None:
                if U_L is None:
                    U_L = npc.eye_like(B[0], 'vL', labels=['vL', 'vR'])
                if V_R is None:
                    V_R = npc.eye_like(B[-1], 'vR', labels=['vR', 'vL']).itranspose()
                cp.segment_boundaries = (U_L, V_R)
        return cp

    def extract_enlarged_segment(self,
                                 psi_left,
                                 psi_right,
                                 first,
                                 last,
                                 add_unitcells=None,
                                 new_first_last=None,
                                 cutoff=1.e-14):
        """Extract an enlarged segment from an initially smaller segment MPS.

        With :meth:`extract_segment`, we obtain a segment MPS on a small subsystem, or "segment"
        of the original system. Yet, such an MPS still has (limited) access to the outside of the
        segment through the Schmidt states to the left and right. While they are given by the
        original states from which we extracted the segment, we can still change local expectation
        values there by adjusting the weights of the Schmidt values.

        Given `self` as the segment MPS and the original background MPS containing the information
        about the Schmidt states, this function allows to define an MPS on an enlarged segment.
        This is particularly useful to evaluate expectation values outside of the original
        segment.

        Parameters
        ----------
        psi_left, psi_right : :class:`~tenpy.networks.mps.MPS`
            Original background MPS to the left and right of `self`.
            May be the same if you're not looking at
            :class:`~tenpy.simulations.ground_state_search.TopologicalExcitations`.
        first, last : int
            The first and last site of the segment that `self` is defined on, in the indexing of the
            original `psi_left` and `psi_right`.
        add_unitcells : int | (int, int)
            How many unit cells (multiples of `psi_left/right.L`) to add to the left and right.
            A single value is used for both directions.
            Note that we also "complete" the unit cells to the left/right even for
            `add_unitcells` = 0. For initially finite MPS with non-trivial `first, last`, this
            yields the state on the full finite system.
        new_first_last : (int, int)
            Alternatively, instead of specifying `add_unit_cells`, directly specify
            the ``(new_first, new_last)`` to be returned.
        cutoff : float
            Cutoff used for QR/SVDs in :meth:`canonical_form_finite`.

        Returns
        -------
        psi_large_seg : :class:`~tenpy.networks.mps.MPS`
            MPS in enlarged segment.
        new_first, new_last : (int, int)
            New first and last site of the enlarge segment used for `psi_large_seg`.
            Like `first`, `last`, this is indexed with respect to the "original" MPSs
            `psi_left` and `psi_right`.
        """
        if (add_unitcells is not None) == (new_first_last is not None):
            raise ValueError("Specify either `add_unitcells` or `new_first_last`!")
        if add_unitcells is not None:
            # get new_first and new_last
            add_unitcells = to_iterable(add_unitcells)
            if len(add_unitcells) == 1:
                add_L = add_R = add_unitcells[0]
            elif len(add_unitcells) == 2:
                add_L, add_R = add_unitcells
            else:
                raise ValueError(f"need 1 or 2 entries in add_unitcells={add_unitcells!r}")
            new_first = int(- add_L * psi_left.L)
            new_last = max(psi_right.L - 1, last)
            if not psi_right.finite:
                # extend to full unit cell to the right if not yet full
                new_last = new_last - (new_last % psi_right.L) + psi_right.L - 1
                new_last = int(new_last + add_R * psi_right.L)
        else:
            new_first, new_last = new_first_last
        if not new_first <= first < last <= new_last:
            raise ValueError("expected new_first <= first < last <= new_last, but got "
                            f"{new_first} {first} {last} {new_last}")
        if new_first < 0 and psi_left.finite or psi_right.finite and new_last >= psi_right.L:
            raise ValueError("Trying to extend segment outside of finite state")

        if new_first == first and new_last == last:
            # nothing to do.  finite bc is okay in this case
            return self, new_first, new_last

        if self.bc != 'segment':
            raise ValueError("only works for segment MPS!")

        # first, last, new_first, new_last are "original" i-indices
        # i = index in original (non-segment) state
        # j = i - first = index in self
        # k = i - new_first = index in final psi_meas = index in Bs/Ss.
        # B[i - new_first] = B[k] where 0 <= k < new_L for new_first <= i <= new_last
        new_L = new_last - new_first + 1

        sites = [None] * new_L # indexed by site k
        Bs = [None] * new_L
        forms = ['B'] * new_L
        Ss = [None] * (new_L + 1) # indexed by bond left of site k

        # get A and left S from psi_left
        for i in range(new_first, first):
            k = i - new_first
            sites[k] = psi_left.sites[i % psi_left.L]
            Bs[k] = psi_left.get_B(i, 'A')
            forms[k] = 'A'
            # needs to be "A" form to ensure we use the S value when going from psi_left to seg
            Ss[k] = psi_left.get_SL(i)
        # get B and both left/right S from self
        for i in range(first, last + 1):
            j = i - first
            k = i - new_first
            sites[k] = self.sites[j]
            Bs[k] = self.get_B(j, 'B')
            Ss[k] = self.get_SL(j)
        Ss[last + 1 - new_first] = self.get_SR(last - first)
        # get all B and right S from psi_right
        for i in range(last + 1, new_last + 1):
            k = i - new_first
            sites[k] = psi_right.sites[i % psi_right.L]
            Bs[k] = psi_right.get_B(i, 'B') # needs to be in "B" form!
            Ss[k + 1] = psi_right.get_SR(i)

        # handle segment_boundaries
        U_L, V_R = self.segment_boundaries
        if U_L is not None and new_first < first:
            k = first - 1 - new_first
            Bs[k] = npc.tensordot(Bs[k], U_L, axes=['vR', 'vL'])
        if V_R is not None and last < new_last:
            k = last + 1 - new_first
            Bs[k] = npc.tensordot(V_R, Bs[k], axes=['vR', 'vL'])

        # initialize MPS
        bc = 'segment'
        if (psi_left.bc == 'finite' and new_first == 0 and
            psi_right.bc == 'finite' and new_last == psi_right.L - 1):
            bc = 'finite'

        psi_new = MPS(sites, Bs, Ss, bc=bc, form=forms)
        psi_new.canonical_form_finite(cutoff=cutoff)  # important: call canonical form
        # this propagates the S from the orthogonality center in the segment to the outer parts

        # handle segment boundaries, remaining cases
        if new_first == first or new_last == last:
            U_L_new, V_R_new = psi_new.segment_boundaries
            if U_L is not None and new_first == first:
                U_L_new = npc.tensordot(U_L, U_L_new, axes=['vR', 'vL'])
            if V_R is not None and new_last == last:
                V_R_new = npc.tensordot(V_R_new, V_R, axes=['vR', 'vL'])
            psi_new.segment_boundaries = (U_L, V_R)

        return psi_new, new_first, new_last

    def get_total_charge(self, only_physical_legs=False):
        """Calculate and return the `qtotal` of the whole MPS (when contracted).

        If set, the :attr:`segment_boundaries` are included (unless `only_physical_legs` is True).

        Parameters
        ----------
        only_physical_legs : bool
            For ``'finite'`` boundary conditions, the total charge can be gauged away
            by changing the LegCharge of the trivial legs on the left and right of the MPS.
            This option allows to project out the trivial legs to get the actual "physical"
            total charge.

        Returns
        -------
        qtotal : charges
            The sum of the `qtotal` of the individual `B` tensors.
        """
        tensors = self._B
        U, V = self.segment_boundaries
        if U is not None:
            assert V is not None
            tensors = tensors + [U, V]
        qtotal = np.sum([B.qtotal for B in tensors], axis=0)
        if only_physical_legs:
            if self.bc != 'finite':
                raise ValueError("`only_physical_legs` not supported for bc=" + repr(self.bc))
            qtotal -= self._B[0].get_leg('vL').get_charge(0)
            qtotal -= self._B[-1].get_leg('vR').get_charge(0)  # takes qconj into account
        return self.chinfo.make_valid(qtotal)

    def gauge_total_charge(self, qtotal=None, vL_leg=None, vR_leg=None):
        """Gauge the legcharges of the virtual bonds s.t. MPS has given `qtotal`; in place.

        Acts in place, i.e. changes the B tensors. Make a (shallow) copy if needed.

        Parameters
        ----------
        qtotal : (list of) charges
            If a single set of charges is given, it is the desired total charge of the MPS
            (which :meth:`get_total_charge` will return afterwards).
            By default (``None``), use 0 charges, unless vL_leg and vR_leg are specified, in which
            case we adjust the total charge to match these legs.
        vL_leg, vR_leg: None | LegCharge
            Desired new virtual leg on the very left and right.
            Needs to have the same block structure as the current legs, but can have shifted
            charge entries.
            For infinite MPS, we need `vL_leg` to be the conjugate leg of `vR_leg`.
            For segment MPS, these legs are the *outer-most* legs, possibly including the
            :attr:`segment_boundaries`.
        """
        if self.chinfo.qnumber == 0:
            return
        if self.segment_boundaries[0] is not None:
            raise NotImplementedError("could be implemented.... do you need this?")
        if vL_leg is not None:
            vL_chdiff = vL_leg.get_charge(0) - self._B[0].get_leg('vL').get_charge(0)
        if vR_leg is not None:
            vR_chdiff = vR_leg.get_charge(0) - self._B[-1].get_leg('vR').get_charge(0)
        if qtotal is None:
            if vL_leg is not None and vR_leg is not None:
                qtotal = self.get_total_charge() + vL_chdiff + vR_chdiff
        qtotal = self.chinfo.make_valid(qtotal)
        if qtotal.ndim == 1:
            qtotal_factor = np.array([0] * (self.L - 1) + [1], npc.QTYPE)
            qtotal = qtotal_factor[:, np.newaxis] * qtotal[np.newaxis, :]
        if qtotal.shape != (self.L, self.chinfo.qnumber):
            raise ValueError("wrong shape of `qtotal`")
        if vL_leg is not None:
            B = self._B[0]
            if np.any(vL_chdiff != 0):
                # adjust left leg
                self._B[0] = B.gauge_total_charge('vL', B.qtotal + vL_chdiff, vL_leg.qconj)
            self._B[0].get_leg('vL').test_equal(vL_leg)
        for i in range(self.L):
            B = self._B[i]
            desired_qtotal = qtotal[i]
            chdiff = B.qtotal - desired_qtotal
            if np.any(chdiff != 0):
                self._B[i] = B.gauge_total_charge('vR', desired_qtotal)
                if i + 1 != self.L:  # this 'vR' is contracted with the 'vL' of the next B
                    # so we need to adjust the next B as well
                    nextB = self._B[i + 1]
                    self._B[i + 1] = nextB.gauge_total_charge('vL', nextB.qtotal + chdiff)
                    self._B[i].get_leg('vR').test_contractible(self._B[i + 1].get_leg('vL'))
        # just to check
        assert np.all(self.get_total_charge() == self.chinfo.make_valid(np.sum(qtotal, 0)))
        if vR_leg is not None:
            # check that the charges match
            self._B[-1].get_leg('vR').test_equal(vR_leg)
        if self.bc == 'infinite':
            self._B[0].get_leg('vL').test_contractible(self._B[-1].get_leg('vR'))
        # done

    def entanglement_entropy(self, n=1, bonds=None, for_matrix_S=False):
        r"""Calculate the (half-chain) entanglement entropy for all nontrivial bonds.

        Consider a bipartition of the system into :math:`A = \{ j: j <= i_b \}` and
        :math:`B = \{ j: j > i_b\}` and the reduced density matrix :math:`\rho_A = tr_B(\rho)`.
        The von-Neumann entanglement entropy is defined as
        :math:`S(A, n=1) = -tr(\rho_A \log(\rho_A)) = S(B, n=1)`.
        The generalization for ``n != 1, n>0`` are the Renyi entropies:
        :math:`S(A, n) = \frac{1}{1-n} \log(tr(\rho_A^2)) = S(B, n=1)`

        This function calculates the entropy for a cut at different bonds `i`, for which the
        the eigenvalues of the reduced density matrix :math:`\rho_A` and :math:`\rho_B` is given
        by the squared schmidt values `S` of the bond.

        Parameters
        ----------
        n : int/float
            Selects which entropy to calculate;
            `n=1` (default) is the usual von-Neumann entanglement entropy.
        bonds : ``None`` | (iterable of) int
            Selects the bonds at which the entropy should be calculated.
            ``None`` defaults to ``range(0, L+1)[self.nontrivial_bonds]``,
            i.e., ``range(1, L)`` for 'finite' MPS and ``range(0, L)`` for 'infinite' MPS.
        for_matrix_S : bool
            Switch calculate the entanglement entropy even if the `_S` are matrices.
            Since :math:`O(\chi^3)` is expensive compared to the usual :math:`O(\chi)`,
            we raise an error by default.

        Returns
        -------
        entropies : 1D ndarray
            Entanglement entropies for half-cuts.
            `entropies[j]` contains the entropy for a cut at bond ``bonds[j]``,
            i.e. between sites ``bonds[j]-1`` and ``bonds[j]``.
            For **infinite** systems with default ``bonds=None``,
            this means that ``entropies[0]`` will be a cut left of site 0 and is the one you should
            look at to e.g. study the scaling of the entanglement with `chi` or to extract
            the topological entanglement entropy - don't take the average over bonds,
            in particular if you have 2D cylinders or ladders.
            On the contrary, for **finite** systems with ``bonds=None``, take the central value
            of the returned array ``entropies[len(entropies)//2)] == entropies[(L-1)//2]``
            (and **not** just ``entropies[L//2]``) to extract the half-chain entanglement entropy.
        """
        if bonds is None:
            nt = self.nontrivial_bonds
            bonds = range(nt.start, nt.stop)
        if isinstance(bonds, int):
            bonds = [bonds]
        res = []
        for ib in bonds:
            if ib == self.L:
                s = self.get_SR(ib-1)
            else:
                s = self.get_SL(ib)
            if len(s.shape) == 1:
                res.append(entropy(s**2, n))
            else:
                if for_matrix_S:
                    # explicitly calculate Schmidt values by diagonalizing (s^dagger s)
                    s = npc.eigvalsh(npc.tensordot(s.conj(), s, axes=[0, 0]))
                    res.append(entropy(s, n))
                else:
                    raise ValueError("entropy with non-diagonal schmidt values")
        return np.array(res)

    def entanglement_entropy_segment(self, segment=[0], first_site=None, n=1):
        r"""Calculate entanglement entropy for general geometry of the bipartition.

        This function is similar as :meth:`entanglement_entropy`,
        but for more general geometry of the region `A` to be a segment of a *few* sites.

        This is achieved by explicitly calculating the reduced density matrix of `A`
        and thus works only for small segments.
        The alternative :meth:`entanglement_entropy_segment2` might work for larger segments
        at small enough bond dimensions.

        Parameters
        ----------
        segment : list of int
            Given a first site `i`, the region ``A_i`` is defined to be ``[i+j for j in segment]``.
        first_site : ``None`` | (iterable of) int
            Calculate the entropy for segments starting at these sites.
            ``None`` defaults to ``range(L-segment[-1])`` for finite
            or `range(L)` for infinite boundary conditions.
        n : int | float
            Selects which entropy to calculate;
            `n=1` (default) is the usual von-Neumann entanglement entropy,
            otherwise the `n`-th Renyi entropy.

        Returns
        -------
        entropies : 1D ndarray
            ``entropies[i]`` contains the entropy for the the region ``A_i`` defined above.
        """
        segment = np.sort(segment)
        if first_site is None:
            if self.finite:
                first_site = range(0, self.L - segment[-1])
            else:
                first_site = range(self.L)
        comb_legs = [
            self._get_p_labels(len(segment), False),
            self._get_p_labels(len(segment), True)
        ]
        res = []
        for i0 in first_site:
            rho = self.get_rho_segment(segment + i0)
            rho = rho.combine_legs(comb_legs, qconj=[+1, -1])
            p = npc.eigvalsh(rho)
            res.append(entropy(p, n))
        return np.array(res)

    def entanglement_entropy_segment2(self, segment, n=1):
        r"""Calculate entanglement entropy for general geometry of the bipartition.

        This function is similar to :meth:`entanglement_entropy_segment`,
        but allows more sites in `segment`.
        The trick is to exploit that for a pure state (which the MPS represents) and a bipartition
        into regions A and B, the entropy is the same in both regions, :math:`S(A) = S(B)`.
        Hence we can trace out the specified segment and obtain :math:`\rho_B = tr_A(rho)`, where
        A is the specified `segment`.
        The price is a *huge* computation cost of :math:`O(chi^6 d^{3x})` where `x` is the number
        of physical legs not included into `segment` between `min(segment)` and `max(segment)`.

        Parameters
        ----------
        segment : list of int
            The site indices specifying region `A`. We calculate and diagonalize
            the full reduced density matrix of the *complement* of `A`.
        n : int | float
            Selects which entropy to calculate;
            `n=1` (default) is the usual von-Neumann entanglement entropy,
            otherwise the `n`-th Renyi entropy.

        Returns
        -------
        entropy : float
            The entropy for the the region defined by the `segment`
            (or equivalently it's complement).
        """
        segment = np.sort(segment)
        if len(segment) < 8:
            warnings.warn("inefficient: use `entanglement_entropy_segment` instead!", stacklevel=2)
        assert np.all(segment[1:] != segment[:-1])  # duplicates in segment
        N_ol = 0  # number of open legs within the segment
        i0 = segment[0]
        rho = self.get_theta(i0, 1)
        rho = npc.tensordot(rho,
                            rho.conj(),
                            axes=(self._get_p_labels(1), self._get_p_labels(1, True)))
        not_in_segment = 0
        ax_p = self._get_p_label('')
        ax_pstar = self._get_p_label('*')
        for i in range(i0 + 1, segment[-1] + 1):
            is_in_segment = (segment[i - i0 - not_in_segment] == i)
            if is_in_segment:
                B = self.get_B(i, form='B')
                rho = npc.tensordot(rho, B, axes=['vR', 'vL'])
                rho = npc.tensordot(rho, B.conj(), axes=(['vR*'] + ax_p, ['vL*'] + ax_pstar))
            else:
                B = self.get_B(i, form='B', label_p=str(not_in_segment))
                rho = npc.tensordot(rho, B, axes=['vR', 'vL'])
                rho = npc.tensordot(rho, B.conj(), axes=['vR*', 'vL*'])
                not_in_segment += 1
        comb_legs = (['vL', 'vR'] + self._get_p_labels(not_in_segment),
                     ['vL*', 'vR*'] + self._get_p_labels(not_in_segment, star=True))
        rho = rho.combine_legs(comb_legs, qconj=[+1, -1])
        p = npc.eigvalsh(rho)
        return entropy(p, n)

    def entanglement_spectrum(self, by_charge=False):
        r"""return entanglement energy spectrum.

        Parameters
        ----------
        by_charge : bool
            Whether we should sort the spectrum on each bond by the possible charges.

        Returns
        -------
        ent_spectrum : list
            For each (non-trivial) bond the entanglement spectrum.
            If `by_charge` is ``False``, return (for each bond) a sorted 1D ndarray
            with the convention :math:`S_i^2 = e^{-\xi_i}`, where :math:`S_i` labels a Schmidt
            value and :math:`\xi_i` labels the entanglement 'energy' in the returned spectrum.
            If `by_charge` is True, return a a list of tuples ``(charge, sub_spectrum)``
            for each possible charge on that bond.
        """
        if by_charge:
            res = []
            for i in range(self.L + 1)[self.nontrivial_bonds]:
                ss = -2. * np.log(self._S[i])
                if i < self.L:
                    leg = self._B[i].get_leg('vL')
                else:  # i == L: segment b.c.
                    leg = self._B[i - 1].get_leg('vR').conj()
                spectrum = [(leg.get_charge(qi), np.sort(ss[leg.get_slice(qi)]))
                            for qi in range(leg.block_number)]
                res.append(spectrum)
            return res
        else:
            return [np.sort(-2. * np.log(ss)) for ss in self._S[self.nontrivial_bonds]]

    def get_rho_segment(self, segment):
        """Return reduced density matrix for a segment.

        Note that the dimension of rho_A scales exponentially in the length of the segment.

        Parameters
        ----------
        segment : iterable of int
            Sites for which the reduced density matrix is to be calculated.
            Assumed to be sorted.

        Returns
        -------
        rho : :class:`~tenpy.linalg.np_conserved.Array`
            Reduced density matrix of the segment sites.
            Labels ``'p0', 'p1', ..., 'pk', 'p0*', 'p1*', ..., 'pk*'`` with ``k=len(segment)``.
        """
        if len(segment) > 12:
            warnings.warn("{0:d} sites in the segment, that's much!".format(len(segment)),
                          stacklevel=2)
        if len(segment) > 20:
            raise ValueError("too large segment; this is exponentially expensive!")
        segment = np.sort(segment)
        if np.all(segment[1:] == segment[:-1] + 1):  # consecutive
            theta = self.get_theta(segment[0], segment[-1] - segment[0] + 1)
            rho = npc.tensordot(theta, theta.conj(), axes=(['vL', 'vR'], ['vL*', 'vR*']))
            return rho
        rho = self.get_theta(segment[0], 1)
        rho = npc.tensordot(rho, rho.conj(), axes=('vL', 'vL*'))
        k = 1
        contract_axes = (['vR*'] + self._p_label, ['vL*'] + self._get_p_label('*'))
        for i in range(segment[0] + 1, segment[-1]):
            B = self.get_B(i)
            if i == segment[k]:
                B = self._replace_p_label(B, str(k))
                k += 1
                rho = npc.tensordot(rho, B, axes=('vR', 'vL'))
                rho = npc.tensordot(rho, B.conj(), axes=('vR*', 'vL*'))
            else:
                rho = npc.tensordot(rho, B, axes=('vR', 'vL'))
                rho = npc.tensordot(rho, B.conj(), axes=contract_axes)
        B = self._replace_p_label(self.get_B(segment[-1]), str(k))
        rho = npc.tensordot(rho, B, axes=('vR', 'vL'))
        rho = npc.tensordot(rho, B.conj(), axes=(['vR*', 'vR'], ['vL*', 'vR*']))
        return rho

    def probability_per_charge(self, bond=0):
        """Return probabilities of charge value on the left of a given bond.

        For example for particle number conservation, define
        :math:`N_b = sum_{i<b} n_i` for a given bond `b`.
        This function returns the possible values of `N_b` as rows of `charge_values`,
        and for each row the probability that this combination occurs in the given state.

        Parameters
        ----------
        bond : int
            The bond to be considered. The returned charges are summed on the left of this bond.

        Returns
        -------
        charge_values : 2D array
            Columns correspond to the different charges in `self.chinfo`.
            Rows are the different charge fluctuations at this bond
        probabilities : 1D array
            For each row of `charge_values` the probability for these values of charge fluctuations.
        """
        if self.bc == 'segment' and bond == self.L:
            S = self.get_SR(self.L - 1)**2
            leg = self.get_B(self.L - 1, form=None).get_leg('vR').conj()
        else:  # usually the case
            S = self.get_SL(bond)**2
            leg = self.get_B(bond, form=None).get_leg('vL')
        assert leg.qconj == +1
        if not leg.is_blocked():
            raise ValueError("leg not blocked: can have duplicate entries in charge values")
        ps = []
        for qi in range(leg.block_number):
            sl = leg.get_slice(qi)
            ps.append(np.sum(S[sl]))
        ps = np.array(ps)
        if abs(np.sum(ps) - 1.) > 1.e-10:
            warnings.warn("Probability_per_charge: Sum of probabilities not 1. Canonical form?",
                          stacklevel=2)
        return leg.charges.copy(), ps

    def average_charge(self, bond=0):
        r"""Return the average charge for the block on the left of a given bond.

        For example for particle number conservation, define
        :math:`N_b = sum_{i<b} n_i` for a given bond `b`.
        Then this function returns :math:`<\psi| N_b |\psi>`.

        Parameters
        ----------
        bond : int
            The bond to be considered.
            The returned charges are summed over the sites left of `bond`.

        Returns
        -------
        average_charge : 1D array
            For each type of charge in :attr:`chinfo`
            the average value when summing the charge values over sites left of the given bond.
        """
        charges, ps = self.probability_per_charge(bond)
        return np.sum(ps[:, np.newaxis] * charges, axis=0)

    def charge_variance(self, bond=0):
        r"""Return the charge variance on the left of a given bond.

        For example for particle number conservation, define
        :math:`N_b = sum_{i<b} n_i` for a given bond `b`.
        Then this function returns :math:`<\psi| N_b^2 |\psi> - (<\psi| N_b |\psi>)^2`.

        Parameters
        ----------
        bond : int
            The bond to be considered.
            The returned charges are summed over the sites left of `bond`.

        Returns
        -------
        average_charge : 1D array
            For each type of charge in :attr:`chinfo`
            the variance of of the charge values left of the given bond.
        """
        charges_mean = self.average_charge(bond)
        charges, ps = self.probability_per_charge(bond)
        return np.sum(ps[:, np.newaxis] * (charges - charges_mean[np.newaxis, :])**2, axis=0)

    def mutinf_two_site(self, max_range=None, n=1):
        """Calculate the two-site mutual information :math:`I(i:j)`.

        Calculates :math:`I(i:j) = S(i) + S(j) - S(i,j)`,
        where :math:`S(i)` is the single site entropy on site :math:`i`
        and :math:`S(i,j)` the two-site entropy on sites :math:`i,j`.

        Parameters
        ----------
        max_range : int
            Maximal distance ``|i-j|`` for which the mutual information should be calculated.
            ``None`` defaults to `L-1`.
        n : float
            Selects the entropy to use, see :func:`~tenpy.tools.math.entropy`.

        Returns
        -------
        coords : 2D array
            Coordinates for the mutinf array.
        mutinf : 1D array
            ``mutinf[k]`` is the mutual information :math:`I(i:j)` between the
            sites ``i, j = coords[k]``.
        """
        #  Basically the code of get_rho_segment and entanglement_entropy,
        #  but optimized to run in O(L*max_range)
        if max_range is None:
            max_range = self.L
        S_i = self.entanglement_entropy_segment(n=n)  # single-site entropy
        legs_ij = self._get_p_labels(2, False), self._get_p_labels(2, True)
        # = (['p0', 'p1'], ['p0*', 'p1*'])
        contr_legs = (
            ['vR*'] + self._get_p_label('1'),  # ['vL', 'p1']
            ['vL*'] + self._get_p_label('1*'))  # ['vL*', 'p1*']
        mutinf = []
        coord = []
        for i in range(self.L):
            rho = self.get_theta(i, 1)
            rho = npc.tensordot(rho, rho.conj(), axes=('vL', 'vL*'))
            jmax = i + max_range + 1
            if self.finite:
                jmax = min(jmax, self.L)
            for j in range(i + 1, jmax):
                B = self._replace_p_label(self.get_B(j, form='B'), '1')  # 'vL', 'vR', 'p1'
                rho = npc.tensordot(rho, B, axes=['vR', 'vL'])
                rho_ij = npc.tensordot(rho, B.conj(), axes=(['vR*', 'vR'], ['vL*', 'vR*']))
                rho_ij = rho_ij.combine_legs(legs_ij, qconj=[+1, -1])
                S_ij = entropy(npc.eigvalsh(rho_ij), n)
                mutinf.append(S_i[i] + S_i[j % self.L] - S_ij)
                coord.append((i, j))
                if j + 1 < jmax:
                    rho = npc.tensordot(rho, B.conj(), axes=contr_legs)
        return np.array(coord), np.array(mutinf)

    def overlap(self, other, charge_sector=None, ignore_form=False, understood_infinite=False,
                **kwargs):
        """Compute overlap ``<self|other>``.

        Parameters
        ----------
        other : :class:`MPS`
            An MPS with the same physical sites.
        charge_sector : None | charges | ``0``
            Selects the charge sector in which the dominant eigenvector of the TransferMatrix is.
            ``None`` stands for *all* sectors, ``0`` stands for the sector of zero charges.
            If a sector is given, it *assumes* the dominant eigenvector is in that charge sector.
        ignore_form : bool
            If ``False`` (default), take into account the canonical form :attr:`form` at each site.
            If ``True``, we ignore the canonical form (i.e., whether the MPS is in left, right,
            mixed or no canonical form) and just contract all the :attr:`_B` as they are.
            (This can give different results!)
        understood_infinite : bool
            Raise a warning to make aware of :ref:`iMPSWarning`.
            Set ``understood_infinite=True`` to suppress the warning.
        **kwargs :
            Further keyword arguments given to :meth:`TransferMatrix.eigenvectors`;
            only used for infinite boundary conditions.

        Returns
        -------
        overlap : dtype.type
            The contraction ``<self|other> * self.norm * other.norm``
            (i.e., taking into account the :attr:`norm` of both MPS).
            For an infinite MPS, ``<self|other>`` is the overlap per unit cell, i.e.,
            the largest eigenvalue of the TransferMatrix.
        """
        if self.bc != other.bc:
            raise ValueError("can't take overlap between MPS with different bc")
        if self.finite:
            if ignore_form:
                # Use TransferMatrix with option to ignore the form
                TM = TransferMatrix(self, other, charge_sector=charge_sector, form=None)
                res = TM.matvec(TM.initial_guess(1.))  # apply transfer matrix to identity
                return npc.trace(res, 0, 1) * self.norm * other.norm
            else:
                env = MPSEnvironment(self, other)
                return env.full_contraction(0)
        else:  # infinite
            if not understood_infinite:
                warnings.warn("The returned overlap between two iMPS is **not** just <phi|psi>, "
                              "as you might assume naively, but here defined to return the "
                              "dominant eigenvalue eta of the (mixed) TransferMatrix. "
                              "The former is lim_{N -> infty} eta^N and vanishes in the "
                              "thermodynamic limit! "
                              "See the warning in the docs of tenpy.networks.mps.")
            form = None if ignore_form else 'B'
            TM = TransferMatrix(self, other, charge_sector=charge_sector, form=form)
            ov, _ = TM.eigenvectors(**kwargs)
            return ov[0] * self.norm * other.norm

    def expectation_value_terms_sum(self, term_list, prefactors=None):
        """Calculate expectation values for a bunch of terms and sum them up.

        This is equivalent to the following expression::

            sum([self.expectation_value_term(term)*strength for term, strength in term_list])

        However, for efficiency, the term_list is converted to an MPO and the expectation value
        of the MPO is evaluated.

        .. deprecated:: 0.4.0
            `prefactor` will be removed in version 1.0.0.
            Instead, directly give just ``TermList(term_list, prefactors)`` as argument.

        Parameters
        ----------
        term_list : :class:`~tenpy.networks.terms.TermList`
            The terms and prefactors (`strength`) to be summed up.
        prefactors :
            Instead of specifying a :class:`~tenpy.networks.terms.TermList`,
            one can also specify the term_list and strength separately.
            This is deprecated.

        Returns
        -------
        terms_sum : list of (complex) float
            Equivalent to the expression
            ``sum([self.expectation_value_term(term)*strength for term, strength in term_list])``.
        _mpo :
            Intermediate results: the generated MPO.
            For a finite MPS, ``terms_sum = _mpo.expectation_value(self)``, for an infinite MPS
            ``terms_sum = _mpo.expectation_value(self) * self.L``

        See also
        --------
        expectation_value_term : evaluates a single `term`.
        tenpy.networks.mpo.MPO.expectation_value : expectation value density of an MPO.
        """
        from . import mpo, terms
        if prefactors is not None:
            warnings.warn(
                "Deprecated argument prefactors: replace arguments with "
                "``TermList(term_list, prefactors)``.", FutureWarning, 2)
            term_list = terms.TermList(term_list, prefactors)
        L = self.L
        if not self.finite:
            copy = None
            for a, term in enumerate(term_list.terms):
                i_min = min([i for _, i in term])
                if not 0 <= i_min < L:
                    if copy is None:
                        # make explicit copy to not modify existing term_list
                        copy = terms.TermList(term_list.terms, term_list.strength)
                    shift = i_min % L - i_min
                    copy.terms[a] = [(op, i + shift) for op, i in term]
            if copy is not None:
                term_list = copy
        # conversion
        ot, ct = term_list.to_OnsiteTerms_CouplingTerms(self.sites)
        bc = 'finite' if self.finite else 'infinite'
        mpo_graph = mpo.MPOGraph.from_terms((ot, ct), self.sites, bc)
        mpo_ = mpo_graph.build_MPO()
        terms_sum = mpo_.expectation_value(self, max_range=ct.max_range())
        if not self.finite:
            terms_sum = terms_sum * self.L
        return terms_sum, mpo_

    def sample_measurements(self,
                            first_site=0,
                            last_site=None,
                            ops=None,
                            rng=None,
                            norm_tol=1.e-12):
        """Sample measurement results in the computational basis.

        This function samples projective measurements on a contiguous range of sites,
        tracing out the remaining sites.

        Note that for infinite boundary conditions, the probability of sampling
        a set of `sigmas` is **not** ``|psi.overlap(MPS.from_product_state(sigmas, ...))|^2``,
        because the latter would project to the set `sigmas` on *each* (translated) MPS unit cell,
        while this function is only projecting to them in a *single* MPS unit cell.

        Parameters
        ----------
        first_site, last_site : int
            Take measurements on the sites in ``range(first_site, last_site + 1)``.
            `last_site` defaults to :attr:`L` - 1.
        ops : list of str
            If not None, sample in the eigenbasis of
            ``self.sites[i].get_op(ops[(i - first_site) % len(ops)])`` and directly return the
            corresponding eigenvalue in `sigmas`.
        rng : :class:`numpy.random.Generator`
            The random number generator; if None, a new `numpy.random.default_rng()` is generated.
        norm_tol : float
            Tolerance

        Returns
        -------
        sigmas : list of int | list of float
            On each site the index of the local basis that was measured,
            as specified in the corresponding :class:`~tenpy.networks.site.Site` in :attr:`sites`.
            Note that this can change depending on whether/what charges you conserve!
            Explicitly specifying the measurement operator will avoid that issue.
        weight : float
            The weight ``sqrt(trace(|psi><psi|sigmas...><sigmas...|))``, i.e.,
            the probability of measuring ``|sigmas...>`` is ``weight**2``.
            For a finite system where we sample all sites (i.e., the trace over the compliment of
            the sites is trivial), this is the actual overlap ``<sigmas...|psi>``
            including the phase.
        """
        if tuple(self._p_label) != ('p', ):
            raise NotImplementedError("Only works for a single physical 'p' leg")
        if last_site is None:
            last_site = self.L - 1
        if rng is None:
            rng = np.random.default_rng()
        sigmas = []
        total_weight = 1.
        theta = self.get_theta(first_site, n=1).replace_label('p0', 'p')
        for i in range(first_site, last_site + 1):
            # theta = wave function in basis vL [sigmas...] p vR
            # where the `sigmas` are already fixed to the measurement results
            i0 = self._to_valid_index(i)
            site = self.sites[i0]
            if ops is not None:
                op_name = ops[(i - first_site) % len(ops)]
                op = site.get_op(op_name).transpose(['p', 'p*'])
                if npc.norm(op - op.conj().transpose()) > 1.e-13:
                    raise ValueError(f"measurement operator {op_name!r} not hermitian")
                W, V = npc.eigh(op)
                theta = npc.tensordot(V.conj(), theta, axes=['p*', 'p']).replace_label('eig*', 'p')
            else:
                W = np.arange(site.dim)
            # perform a projective measurement:
            # trace out rest except site `i`
            rho = npc.tensordot(theta.conj(), theta, [['vL*', 'vR*'], ['vL', 'vR']])
            # probabilities p(sigma) = <sigma|rho|sigma>
            rho_diag = np.abs(np.diag(rho.to_ndarray()))  # abs: real dtype & roundoff err
            if abs(np.sum(rho_diag) - 1.) > norm_tol:
                raise ValueError("not normalized to `norm_tol`")
            rho_diag /= np.sum(rho_diag)
            sigma = rng.choice(site.dim, p=rho_diag)  # randomly select index from probabilities
            sigmas.append(W[sigma])
            theta = theta.take_slice(sigma, 'p')  # project to sigma in theta for remaining rho
            weight = npc.norm(theta)
            total_weight *= weight
            if i != last_site:
                # attach next site to sigma
                theta = theta / npc.norm(theta)
                B = self.get_B(i + 1)
                theta = npc.tensordot(theta, B, axes=['vR', 'vL'])
                # B is right-canonical -> theta still normalized
            elif self.bc == 'finite' and first_site == 0 and last_site == self.L - 1:
                assert theta.shape == (1, 1)
                # already divided by norm, so only include the phase now
                total_weight = total_weight * theta[0, 0] / weight
        return sigmas, total_weight

    def norm_test(self):
        """Check that self is in canonical form.

        Returns
        -------
        norm_error: array, shape (L, 2)
            For each site the norm error to the left and right.
            The error ``norm_error[i, 0]`` is defined as the norm-difference between
            the following networks::

                |   --theta[i]---.       --s[i]--.
                |       |        |    vs         |
                |   --theta*[i]--.       --s[i]--.

            Similarly, ``norm_error[i, 1]`` is the norm-difference of::

                |   .--theta[i]---         .--s[i+1]--
                |   |    |          vs     |
                |   .--theta*[i]--         .--s[i+1]--
        """
        err = np.empty((self.L, 2), dtype=float)
        lbl_R = (self._get_p_label('0') + ['vR'], self._get_p_label('0*') + ['vR*'])
        lbl_L = (['vL'] + self._get_p_label('0'), ['vL*'] + self._get_p_label('0*'))
        for i in range(self.L):
            th = self.get_theta(i, 1)
            rho_L = npc.tensordot(th, th.conj(), axes=lbl_R)
            S = self.get_SL(i)
            if isinstance(S, npc.Array):  # during DMRG with mixer, S may be a 2D npc.Array
                if S.rank != 2:
                    raise ValueError("Expect 2D npc.Array or 1D numpy ndarray")
                rho_L2 = npc.tensordot(S, S.conj(), axes=['vR', 'vR*'])
            else:
                rho_L2 = npc.diag(S**2, rho_L.get_leg('vL'), dtype=rho_L.dtype)
            err[i, 0] = npc.norm(rho_L - rho_L2)
            rho_R = npc.tensordot(th, th.conj(), axes=lbl_L)
            S = self.get_SR(i)
            if isinstance(S, npc.Array):
                if S.rank != 2:
                    raise ValueError("Expect 2D npc.Array or 1D numpy ndarray")
                rho_R2 = npc.tensordot(S, S.conj(), axes=['vL', 'vL*'])
            else:
                rho_R2 = npc.diag(S**2, rho_R.get_leg('vR'), dtype=rho_L.dtype)
            err[i, 1] = npc.norm(rho_R - rho_R2)
        return err

    def canonical_form(self, **kwargs):
        """Bring self into canonical 'B' form, (re-)calculate singular values; in place.

        Simply calls :meth:`canonical_form_finite` or :meth:`canonical_form_infinite1`.
        Keyword arguments are passed on to the corresponding specialized versions.
        """
        if self.finite:
            return self.canonical_form_finite(**kwargs)
        else:
            return self.canonical_form_infinite1(**kwargs)

    def canonical_form_finite(self, renormalize=True, cutoff=0., envs_to_update=None):
        """Bring a finite (or segment) MPS into canonical form; in place.

        If any site is in :attr:`form` ``None``, it does *not* use any of the singular values `S`
        (for 'finite' boundary conditions, or only the very left `S` for 'segment' b.c.).
        If all sites have a `form`, it respects the `form` to ensure
        that one `S` is included per bond.
        The final state is always in right-canonical 'B' form.

        Performs one sweep left to right doing QR decompositions, and one sweep right to left
        doing SVDs calculating the singular values.

        Parameters
        ----------
        renormalize: bool
            Whether a change in the norm should be discarded or used to *update* :attr:`norm`.
            Note that even `renormalize=True` *does not reset* the :attr:`norm` to 1.
            To do that, you would rather have to set ``psi.norm = 1`` explicitly!
        cutoff : float | None
            Cutoff of singular values used in the SVDs.
        envs_to_update : None | list of :class:`MPSEnvironment`
            Clear the environments; for segment also update the left/rightmost LP/RP.

        Returns
        -------
        U_L, V_R : :class:`~tenpy.linalg.np_conserved.Array`
            Only returned for ``'segment'`` boundary conditions.
            The unitaries defining the new left and right Schmidt states in terms of the old ones,
            with legs ``'vL', 'vR'``.
        """
        assert (self.finite)
        L = self.L
        assert (L > 1)  # otherwise implement yourself...
        # normalize very left singular values
        S = self.get_SL(0)
        if self.bc == 'segment':
            if S is None:
                raise ValueError("Need S[0] and S[L] for segment boundary conditions.")
            self.set_SL(0, S / np.linalg.norm(S))
            S = self.get_SR(L - 1)
            self.set_SR(L - 1, S / np.linalg.norm(S))
        else:  # bc == 'finite':
            self.set_SL(0, np.array([1.]))  # trivial singular value on very left/right
            self.set_SR(L - 1, np.array([1.]))
        # sweep from left to right to bring it into left canonical form.
        if any([(f is None) for f in self.form]):
            # ignore any 'S' and canonical form
            M = self.get_B(0, form=None)
            form = None
        else:
            # we actually had a canonical form before, so we should *not* ignore the 'S'
            M = self.get_B(0, form='Th')
            form = 'B'  # for other 'M'
        Q, R = npc.qr(M.combine_legs(['vL'] + self._p_label), inner_labels=['vR', 'vL'])
        # Q = unitary, R has to be multiplied to the right
        self.set_B(0, Q.split_legs(0), form='A')
        for i in range(1, L - 1):
            M = self.get_B(i, form)
            M = npc.tensordot(R, M, axes=['vR', 'vL'])
            Q, R = npc.qr(M.combine_legs(['vL'] + self._p_label), inner_labels=['vR', 'vL'])
            # Q is unitary, i.e. left canonical, R has to be multiplied to the right
            self.set_B(i, Q.split_legs(0), form='A')
        M = self.get_B(L - 1, form)
        M = npc.tensordot(R, M, axes=['vR', 'vL'])
        if self.bc == 'segment':
            # also need to calculate new singular values on the very right
            U, S, VR_segment = npc.svd(M.combine_legs(['vL'] + self._p_label),
                                       cutoff=cutoff,
                                       qtotal_LR=[M.qtotal, None],
                                       inner_labels=['vR', 'vL'])
            S /= np.linalg.norm(S)
            self.set_SR(L - 1, S)
            M = U.scale_axis(S, 1).split_legs(0)
        else:
            VR_segment = None
        # sweep from right to left, calculating all the singular values
        U, S, V = npc.svd(M.combine_legs(['vR'] + self._p_label, qconj=-1),
                          cutoff=cutoff,
                          inner_labels=['vR', 'vL'])
        if not renormalize:
            self.norm = self.norm * np.linalg.norm(S)
        S = S / np.linalg.norm(S)  # normalize
        self.set_SL(L - 1, S)
        self.set_B(L - 1, V.split_legs(1), form='B')
        for i in range(L - 2, -1, -1):
            M = self.get_B(i, 'A')
            M = npc.tensordot(M, U.scale_axis(S, 'vR'), axes=['vR', 'vL'])
            U, S, V = npc.svd(M.combine_legs(['vR'] + self._p_label, qconj=-1),
                              cutoff=cutoff,
                              qtotal_LR=[None, M.qtotal],
                              inner_labels=['vR', 'vL'])
            S = S / np.linalg.norm(S)  # normalize
            self.set_SL(i, S)
            self.set_B(i, V.split_legs(1), form='B')
        if self.bc == 'finite':
            assert len(S) == 1
            self._B[0] *= U[0, 0]  # just a trivial phase factor, but better keep it
        # done with getting to canonical form
        if envs_to_update is not None and self.bc == 'segment':
            for env in envs_to_update:
                update_ket = env.ket is self
                update_bra = env.bra is self
                if not (update_ket or update_bra):
                    raise ValueError("called `psi.canonical_form_finite(..., envs_to_update), "
                                     "but (one of) the environment doesn't contain that `psi`")
                env.clear()
                if self.bc == 'segment':
                    env._update_gauge_LP(0, U, update_bra, update_ket)
                    env._update_gauge_RP(env.L - 1, VR_segment, update_bra, update_ket)
        if self.bc == 'segment':
            old_UL, old_VR = self.segment_boundaries
            if old_UL is not None:
                new_UL = npc.tensordot(old_UL, U, axes=['vR', 'vL'])
                new_VR = npc.tensordot(VR_segment, old_VR, axes=['vR', 'vL'])
                self.segment_boundaries = (new_UL, new_VR)
            else:
                self.segment_boundaries = (U, VR_segment)
            return U, VR_segment

    def canonical_form_infinite(self, **kwargs):
        """Deprecated wrapper around :meth:`canonical_form_infinite1`."""
        warnings.warn(
            "There are different implementations of `canonical_form_infinite` now. "
            "Select one explicitly!",
            FutureWarning,
            stacklevel=2)
        self.canonical_form_infinite1(**kwargs)

    def canonical_form_infinite1(self, renormalize=True, tol_xi=1.e6):
        """Bring an infinite MPS into canonical form; in place.

        If any site is in :attr:`form` ``None``, it does *not* use any of the singular values `S`.
        If all sites have a `form`, it respects the `form` to ensure
        that one `S` is included per bond.
        The final state is always in right-canonical 'B' form.

        Proceeds in three steps, namely 1) diagonalize right and left transfermatrix on a given
        bond to bring that bond into canonical form, and then
        2) sweep right to left, and 3) left to right to bringing other bonds into canonical form.

        .. warning :
            You might *loose* precision when calling this function.
            When we diagonalize the transfermatrix, we get the singular values squared as
            eigenvalues, with numerical noise on the order of machine precision (usually ~1.e-15).
            Taking the square root, the new singular values are only precise to *half* the machine
            precision (usually ~1.e-7).

        Parameters
        ----------
        renormalize: bool
            Whether a change in the norm should be discarded or used to update :attr:`norm`.
            Note that even `renormalize=True` *does not reset* the :attr:`norm` to 1.
            To do that, you would rather have to set ``psi.norm = 1`` explicitly!
        tol_xi : float
            Raise an error if the correlation length is larger than that
            (which indicates a degenerate "cat" state, e.g., for spontaneous symmetry breaking).
        """
        assert not self.finite
        L = self.L
        i1 = np.argmin(self.chi) % L  # start at this bond
        if any([(f is None) for f in self.form]):
            # ignore any 'S' and canonical form, just state that we are in 'B' form
            self.form = self._parse_form('B')
            self._S[i1] = np.ones(self.chi[i1], dtype=np.float64)  # (later used for guess of Gl)
        else:
            # was in canonical form before; bring back into canonical form
            # -> make sure we don't use multiple S on one bond in our definition of the MPS
            self.convert_form('B')
        Wr_list = [None] * L  # right eigenvectors of TM on each bond after ..._correct_right

        # phase 1: bring bond (i1-1, i1) in canonical form
        # find dominant right eigenvector
        norm, Gr = self._canonical_form_dominant_gram_matrix(i1, False, tol_xi)
        self._B[i1] /= np.sqrt(norm)  # correct norm
        if not renormalize:
            self.norm *= np.sqrt(norm)
        # make Gr diagonal to Wr
        Wr, Kl, Kr = self._canonical_form_correct_right(i1, Gr)
        # guess for Gl
        Gl = npc.tensordot(Kr.scale_axis(self.get_SL(i1)**2, 1), Kl, axes=['vR', 'vL'])
        Gl.iset_leg_labels(['vR*', 'vR'])
        # find dominant left eigenvector
        norm, Gl = self._canonical_form_dominant_gram_matrix(i1, True, tol_xi, Gl)
        if abs(1. - norm) > 1.e-13:
            logger.warning("Although we renormalized the TransferMatrix, "
                           "the largest eigenvalue is not 1")  # (this shouldn't happen)
        self._B[i1] /= np.sqrt(norm)  # correct norm again
        if not renormalize:
            self.norm *= np.sqrt(norm)
        # bring bond to canonical form
        Gl, Yl, Yr = self._canonical_form_correct_left(i1, Gl, Wr)
        Wr = np.ones(Yr.legs[0].ind_len, np.float64)
        # now the bond (i1-1,i1) is in canonical form
        Wr_list[i1] = Wr  # diag(Wr) is right eigenvector on bond (i1-1, i1)

        # phase 2: sweep from right to left; find other right eigenvectors and make them diagonal
        for j1 in range(i1 - 1, i1 - L, -1):
            B1 = self.get_B(j1, 'B')
            axes = [self._p_label + ['vR'], self._get_p_label('*') + ['vR*']]
            Gr = npc.tensordot(B1.scale_axis(Wr, 'vR'), B1.conj(), axes=axes)
            Wr, Kl, Kr = self._canonical_form_correct_right(j1, Gr)
            Wr_list[j1 % L] = Wr

        # phase 3: sweep from left to right; find other left eigenvectors,
        # bring each bond into canonical form
        for j1 in range(i1 - L + 1, i1, +1):
            # find Gl on bond j1-1, j1
            B1 = self.get_B(j1 - 1, 'B')
            Gl = npc.tensordot(
                B1.conj(),  # old B1; now on site j1-1
                npc.tensordot(Gl, B1, axes=['vR', 'vL']),
                axes=[self._get_p_label('*') + ['vL*'], self._p_label + ['vR*']])
            # axes=[['p*', 'vL*'], ['p', 'vR*']])
            Gl, Yl, Yr = self._canonical_form_correct_left(j1, Gl, Wr_list[j1 % L])
        # done

    def canonical_form_infinite2(self,
                                 renormalize=True,
                                 tol=1.e-15,
                                 arnoldi_params=None,
                                 cutoff=1.e-15):
        """Convert infinite MPS to canonical form; in place.

        Implementation following Algorithm 1,2 in :cite:`vanderstraeten2019`.

        Parameters
        ----------
        renormalize: bool
            Whether a change in the norm should be discarded or used to update :attr:`norm`.
            Note that even `renormalize=True` *does not reset* the :attr:`norm` to 1.
            To do that, you would rather have to set ``psi.norm = 1`` explicitly!
        tol : float
            Precision down to which the state should be in canonical form.
        arnoldi_params : dict
            Parameters for :class:`~tenpy.linalg.lanczos.Arnoldi`.
        cutoff :
            Truncation cutoff for small singular values.
        """
        assert not self.finite
        assert cutoff <= tol
        if arnoldi_params is None:
            arnoldi_params = asConfig({}, 'arnoldi_params')
        if any([(f is None) for f in self.form]):
            # ignore any 'S' and canonical form, just state that we are in 'B' form
            self.form = self._parse_form('B')
            self._S[0] = np.ones(self.chi[0], dtype=np.float64)  # later used for C_guess
        else:
            # was in canonical form before; bring back into canonical form
            # -> make sure we don't use multiple S on one bond in our definition of the MPS
            self.convert_form('B')
        # self._B holds original B
        R_guess = npc.diag(1., self._B[0].get_leg('vL'), labels=['vL', 'vR'])
        new_Bs, _, norm = self._canonical_form_right_orthogonalize(R_guess, tol, arnoldi_params)
        if not renormalize:
            self.norm *= norm
        # now we have old_Bs R = R new_Bs with right-orthonormal new_Bs
        self._B = new_Bs
        C_guess = npc.diag(self.get_SL(0), self._B[0].get_leg('vL'), labels=['vL', 'vR'])
        # TODO: we sometimes got a legcharge error when using R_guess instead off C_guess,
        # so the oder of the indices might have changed (from sorting legs?)
        # reflect this in permutation of singular values
        new_As, C, _ = self._canonical_form_left_orthogonalize(C_guess, tol, arnoldi_params)
        # now we have C new_Bs = new_As C with left and right-orthonormal A/B
        # but not yet diagonal S
        C.itranspose(['vL', 'vR'])
        U, S, V = npc.svd(C, cutoff=cutoff, inner_labels=['vR', 'vL'])
        # now S V new_Bs V^d = U^d C new_Bs V^d = U^d new_As C V^d = U^d new_As U S
        # so V new_Bs V^d is right-canonical with diagonal S on bond (-1, 0)
        # and U^d new_As U is left-canonical with diagonal S on bond (-1, 0)
        # we could update self._Bs here, but we overwrite them in the following loop
        new_As[0] = npc.tensordot(U.conj().ireplace_label('vR*', 'vL'),
                                  new_As[0],
                                  axes=['vL*', 'vL'])
        #  new_As[-1] = npc.tensordot(new_As[-1], U, axes=['vR', 'vL']) # is done in loop below
        # get S with a bunch of SVDs
        for i in reversed(range(len(new_As))):
            th = npc.tensordot(new_As[i], U.scale_axis(S, 'vR'), axes=['vR', 'vL'])
            th = th.combine_legs(self._p_label + ['vR'], new_axes=1)
            U, S, V = npc.svd(th, cutoff=cutoff, inner_labels=['vR', 'vL'])
            self._B[i] = V.split_legs()
            self.set_SL(i, S)
        # note: we included SVD on i=0; else the virtual leg (-1, 0) might not even be sorted
        self._B[-1] = npc.tensordot(self._B[-1], U, axes=['vR', 'vL'])

    def _canonical_form_left_orthogonalize(self, L, tol, arnoldi_params):
        max_iters = 10_000
        for _ in range(max_iters):
            L /= npc.norm(L)
            L_old = L
            new_As, L = self._canonical_form_qr_L2R(L)
            norm = npc.norm(L)
            L /= norm
            L.itranspose(L_old.get_leg_labels())
            err = npc.norm(L - L_old)
            if err <= tol:
                return new_As, L, norm
            # get better guess for L with Arnoldi
            arnoldi_params['E_tol'] = err / 10.
            TM = TransferMatrix.from_Ns_Ms(new_As, self._B, transpose=True)
            L.ireplace_label('vL', 'vR*')
            E, Ls, N = Arnoldi(TM, L, arnoldi_params).run()
            L = Ls[0]
            L.ireplace_label('vR*', 'vL')
            # again QR to get positive diagonal part of L, in same way as in _canonical_form_qr_L2R
            _, L = npc.qr(L.itranspose(['vL', 'vR']),
                          inner_labels=['vR', 'vL'],
                          pos_diag_R=True,
                          inner_qconj=+1)
        msg = (f'canonical_form did not converge up to tol={tol}. '
               f'Final error after {max_iters} iterations: {err}. '
               f'Consider increasing the tolerance, but proceed with care.')
        raise RuntimeError(msg)

    def _canonical_form_right_orthogonalize(self, R, tol, arnoldi_params):
        max_iters = 10_000
        for _ in range(max_iters):
            R /= npc.norm(R)
            R_old = R
            new_Bs, R = self._canonical_form_qr_R2L(R)
            norm = npc.norm(R)
            R /= norm
            R.itranspose(R_old.get_leg_labels())
            err = npc.norm(R - R_old)
            if err <= tol:
                return new_Bs, R, norm
            #  _, R = self._canonical_form_arnoldi(new_Bs, R, err/10.)
            TM = TransferMatrix.from_Ns_Ms(new_Bs, self._B, transpose=False)
            R.ireplace_label('vR', 'vL*')
            arnoldi_params['E_tol'] = err / 10.
            E, Rs, N = Arnoldi(TM, R, arnoldi_params).run()
            R = Rs[0]
            R.ireplace_label('vL*', 'vR')
            # again QR to get positive diagonal part of R, in same way as in _canonical_form_qr_R2L
            _, R = npc.qr(R.itranspose(['vR', 'vL']),
                          inner_labels=['vL', 'vR'],
                          pos_diag_R=True,
                          inner_qconj=-1)
        msg = (f'canonical_form did not converge up to tol={tol}. '
               f'Final error after {max_iters} iterations: {err}. '
               f'Consider increasing the tolerance, but proceed with care.')
        raise RuntimeError(msg)

    def _canonical_form_qr_L2R(self, L):
        """QR-decompose ``L B[0] B[1] ... B[-1] -> Qs[0]... Qs[-1] L`` for Bs in ``self._B``."""
        Qs = [None] * self.L
        for i in range(self.L):
            LB = npc.tensordot(L, self._B[i], axes=['vR', 'vL'])
            LB = LB.combine_legs(['vL'] + self._p_label, new_axes=0, qconj=+1)
            Q, L = npc.qr(LB,
                          inner_labels=['vR', 'vL'],
                          pos_diag_R=True,
                          qtotal_Q=LB.qtotal,
                          inner_qconj=+1)
            Qs[i] = Q.split_legs()
        return Qs, L

    def _canonical_form_qr_R2L(self, R):
        """QR-decompose ``B[0] B[1] ... B[-1] R -> R Qs[0]... Qs[-1]`` for Bs in ``self._B``."""
        Qs = [None] * self.L
        for i in reversed(range(self.L)):
            BR = npc.tensordot(self._B[i], R, axes=['vR', 'vL'])
            BR = BR.combine_legs(self._p_label + ['vR'], new_axes=0, qconj=-1)
            Q, R = npc.qr(BR,
                          inner_labels=['vL', 'vR'],
                          pos_diag_R=True,
                          qtotal_Q=BR.qtotal,
                          inner_qconj=-1)
            Qs[i] = Q.split_legs()
        return Qs, R

    def correlation_length(self, target=1, tol_ev0=1.e-8, charge_sector=0, return_charges=False):
        r"""Calculate the correlation length by diagonalizing the transfer matrix.

        Assumes that `self` is in canonical form.

        Works only for infinite MPS, where the transfer matrix is a useful concept.
        Assuming a single-site unit cell, any correlation function splits into
        :math:`C(A_i, B_j) = A'_i T^{j-i-1} B'_j`
        with some parts left and right and the :math:`j-i-1`-th power of the transfer matrix in
        between. The largest eigenvalue is 1 (if self is properly normalized)
        and gives the dominant contribution of
        :math:`A'_i E_1 * 1^{j-i-1} * E_1^T B'_j = <A> <B>`,
        and the second largest one gives a contribution :math:`\propto \lambda_2^{j-i-1}`.
        Thus :math:`\lambda_2 = \exp(-\frac{1}{\xi})`.

        More general for a `L`-site unit cell we get :math:`\lambda_2 = \exp(-\frac{L}{\xi})`,
        where the `xi` is given in units of 1 lattice spacing in the MPS.

        .. warning ::
            For a higher-dimensional lattice (which the MPS class doesn't know about),
            the correct unit is the lattice spacing in x-direction, and the correct formula is
            :math:`\lambda_2 = \exp(-\frac{L_x}{\xi})`,
            where `L_x` is the number of lattice spacings in the infinite direction within the
            MPS unit cell, e.g. the number of "rings" of a cylinder in the MPS unit cell.
            To get to these units, divide the returned `xi` by the number of sites within a "ring",
            for a lattice given in :attr:`~tenpy.models.lattice.Lattice.N_sites_per_ring`.

        Parameters
        ----------
        target : int
            We look for the `target` + 1 largest eigenvalues.
        tol_ev0 : float | None
            Print warning if largest eigenvalue deviates from 1 by more than `tol_ev0`.
            If `None`, **assume** dominant eigenvector in 0-charge-sector to be 1 for
            non-zero `charge_sector`.
        charge_sector : None | list of int | ``0`` | list of list of int
            Selects the charge sector (=list of int) in which we look for the dominant eigenvalue
            of the TransferMatrix.
            ``None`` stands for *all* sectors, ``0`` stands for the zero-charge sector.
            Defaults to ``0``, i.e., **assumes** the dominant eigenvector is in charge sector 0.
            If you pass a list of charge sectors (i.e. 2D array of int),
            this function returns `target` dominant eigenvalues in each of those sectors.
        return_charges : bool
            If True, return the charge sectors along with the eigenvalues.

        Returns
        -------
        xi : float | 1D array
            If `target` = 1, return just the correlation length,
            otherwise an array of the `target` largest correlation lengths.
            It is measured in units of a single spacing between sites in the MPS language,
            see the warning above.
        charge_sectors :  list of charge sectors
            For each entry in `xi` the charge sector, i.e., qtotal of the dominant eigenvalue.

        See also
        --------
        correlation_length_charge_sectors : lists possible charge sectors.
        """
        assert (not self.finite)
        zero_charge = self.chinfo.make_valid()
        if any(chi == 1 for chi in self.chi):
            # product states have zero correlation length
            if return_charges:
                if target == 1:
                    return 0, zero_charge
                return [0] * target, [zero_charge] * target
            return 0. if target == 1 else [0] * target
        if charge_sector is not None and isinstance(charge_sector, Iterable):
            # iterable check excludes charge_sector=0 (c.f. issue 289)
            charge_sector = self.chinfo.make_valid(charge_sector)
        elif charge_sector is None:
            pass
        else:
            assert charge_sector == 0
            charge_sector = zero_charge
        num = max(target + 1, self._transfermatrix_keep)
        # now charge_sector is None or 1D or 2D ndarray (but not 0)
        if charge_sector is None or charge_sector.ndim == 1:
            # a single charge sector or charge_sector=None -> (only dominant eigvals for all charge_sectors)
            T = TransferMatrix(self, self, charge_sector=charge_sector, form='B')
            E, V = T.eigenvectors(num, which='LM')
            # note: LM implies E is sorted largest magnitude first
            if return_charges:
                V_charges = [vec.qtotal for vec in V]
            looked_in_zero_charge_sector = charge_sector is None or np.all(charge_sector == 0)
        else:
            assert charge_sector.ndim == 2
            # loop over different charge sectors
            charge_sector_list = charge_sector
            T = TransferMatrix(self, self, form='B')
            E = []
            V_charges = []
            for charge_sector in charge_sector_list:
                T.charge_sector = charge_sector
                E_s, V_s = T.eigenvectors(num, which='LM')
                E.extend(E_s)
                if return_charges:
                    V_charges.extend([vec.qtotal for vec in V_s])
            sort = argsort(E, 'LM')
            E = np.array(E)[sort]
            if return_charges:
                V_charges = [V_charges[i] for i in sort]
            looked_in_zero_charge_sector = np.any(np.all(charge_sector_list == 0, axis=1))

        if not looked_in_zero_charge_sector:
            # need to add the eigval 1 from the 0 charge sector
            if tol_ev0 is not None:
                # diagonalize zero_charge sector
                T.charge_sector = zero_charge
                E0, _ = T.eigenvectors(num, which='LM')
                E0 = E0[0]
            else:
                E0 = 1.   # explicitly set it by hand
            if not abs(E0) > abs(E[0]):
                # shouldn't happen... error handling or warning with only numerical errors?
                if tol_ev0 is not None and abs(E[0]) - abs(E0) < tol_ev0:
                    prec = tol_ev0
                elif tol_ev0 is None and abs(E[0]) - abs(E0) < 1.e-5:
                    prec = 1.e-5
                else:
                    prec = None
                if prec is not None:
                    logger.warning("correlation_length: other charge sector has eigenvalue "
                                   " bigger than the eigenvalue 1. in the zero charge sector, "
                                   "but still within precision {prec:.1e}")
                    E0 = E[0] + prec
                else:
                    raise ValueError("dominant eigenvalue is not in zero charge sector???")
            E = [E0] + list(E)
            if return_charges:
                V_charges = [None] + V_charges
        if tol_ev0 is not None and abs(E[0] - 1.) > tol_ev0:
            logger.warning(f"Correlation length: largest eigenvalue not one, but {E[0]:.12f}. "
                            "Not in canonical form/normalized?")
        assert len(E) >= 2
        E = np.array(E)
        xis = -1. / np.log(np.abs(E[1:target + 1] / E[0])) * self.L
        # finally return
        if return_charges:
            if target == 1:
                return xis[0], V_charges[1]
            return xis, V_charges[1:]
        else:
            if target == 1:
                return xis[0]
            return xis

    def correlation_length_charge_sectors(self, drop_symmetric=True, include_0=True):
        """Return possible `charge_sector` argument for :meth:`correlation_length`.

        The :meth:`correlation_length` is calculated from eigenvalues of the transfer matrix.
        The left/right eigenvectors correspond to contraction of the left/right parts of
        the transfer-matrix in the network of the :meth:`correlation_function`.
        The `charge_sector` one can pass to the :meth:`correlation_length` (or
        :class:`TransferMatrix`, respectively) is the `qtotal` that eigenvector.

        Since bra and ket are identical for the :meth:`correlation_length`, one can flip
        top and bottom and to an overall `conjugate`, and gets back to the same TransferMatrix,
        hence eigenvalues of a given eigenvector and it's dagger (seen as a matrix with legs
        ``'vL', 'vL*'``) are identical. Since that flips the sign of all charges, we can conclude
        that the correlation length in a given charge sector and the negative charge sector are
        identical.
        The option `drop_symmetric` hence allows to only return charge sectors where the negative
        charge sector was not yet returned.

        Parameters
        ----------
        drop_symmetric : bool
            See above.
        """
        if self.chinfo.qnumber == 0:
            return []
        vR = self.get_B(self.L - 1).get_leg('vR')
        pipe = npc.LegPipe([vR, vR.conj()], qconj=-1).conj()
        charges = pipe.charges  # this is lexsorted
        if not drop_symmetric:
            return charges
        conj_charges = self.chinfo.make_valid(-charges)
        perm = np.lexsort(conj_charges.T)
        keep = (perm <= np.arange(len(perm)))
        # note: the equal is necessary to include 0 and e.g. 2 for a Z_4 charge.
        return charges[keep]

    def add(self, other, alpha, beta, cutoff=1.e-15):
        """Return an MPS which represents ``alpha|self> + beta |others>``.

        Works only for 'finite', 'segment' boundary conditions.
        For 'segment' boundary conditions, the virtual legs on the very left/right are
        assumed to correspond to each other (i.e. self and other have the same state outside of
        the considered segment).
        Takes into account :attr:`norm`.

        Parameters
        ----------
        other : :class:`MPS`
            Another MPS of the same length to be added with self.
        alpha, beta : complex float
            Prefactors for self and other. We calculate
            ``alpha * |self> + beta * |other>``
        cutoff : float | None
            Cutoff of singular values used in the SVDs.

        Returns
        -------
        sum : :class:`MPS`
            An MPS representing ``alpha|self> + beta |other>``.
            Has same total charge as `self`.
        """
        L = self.L
        assert (other.L == L and L >= 2)  # (if you need this, generalize this function...)
        assert self.finite
        assert self.bc == other.bc
        other = self._gauge_compatible_vL_vR(other)
        legs = ['vL', 'vR'] + self._p_label
        # alpha and beta appear only on the first site
        alpha = alpha * self.norm
        beta = beta * other.norm
        theta_self = self.get_B(0, 'Th').transpose(legs)
        theta_other = other.get_B(0, 'Th').transpose(legs)
        last_B_self = self.get_B(L - 1).transpose(legs)
        last_B_other = other.get_B(L - 1).transpose(legs)
        U, V = self.segment_boundaries
        if U is not None:
            theta_self = npc.tensordot(U, theta_self, axes=['vR', 'vL']).transpose(legs)
            last_B_self = npc.tensordot(last_B_self, V, axes=['vR', 'vL']).transpose(legs)
        U, V = other.segment_boundaries
        if U is not None:
            theta_other = npc.tensordot(U, theta_other, axes=['vR', 'vL']).transpose(legs)
            last_B_other = npc.tensordot(last_B_other, V, axes=['vR', 'vL']).transpose(legs)
        Bs = [npc.grid_concat([[alpha * theta_self, beta * theta_other]], axes=[0, 1])]
        for i in range(1, L - 1):
            B1 = self.get_B(i).transpose(legs)
            B2 = other.get_B(i).transpose(legs)
            grid = [[B1, npc.zeros([B1.get_leg('vL'), B2.get_leg('vR')] + B1.legs[2:])],
                    [npc.zeros([B2.get_leg('vL'), B1.get_leg('vR')] + B1.legs[2:]), B2]]
            Bs.append(npc.grid_concat(grid, [0, 1]))
        Bs.append(npc.grid_concat([[last_B_self], [last_B_other]], axes=[0, 1]))
        Ss = [np.ones(Bs[0].shape[0])] + [np.ones(B.shape[1]) for B in Bs]
        psi = self.__class__(self.sites, Bs, Ss, self.bc, form=None)  # new class instance
        # bring to canonical form, calculate Ss
        psi.canonical_form_finite(renormalize=False, cutoff=cutoff)
        return psi

    def apply_local_op(self, i, op, unitary=None, renormalize=False, cutoff=1.e-13,
                       understood_infinite=False):
        r"""Apply a local (one or multi-site) operator to `self`. In place.

        Note that this destroys the canonical form if the local operator is non-unitary.
        Therefore, this function calls :meth:`canonical_form` if necessary.

        For infinite MPS, it applies the operator **in parallel** within each unit site,
        i.e., really it applies :math:`\prod_{u \in \mathbb{Z}} (\mathrm{op}_{i + u *L})`
        where :attr:`L` is the number of sites in the MPS unit cell.

        Parameters
        ----------
        i : int
            (Left-most) index of the site(s) on which the operator should act.
        op : str | npc.Array
            A physical operator acting on site `i`, with legs ``'p', 'p*'`` for a single-site
            operator or with legs ``['p0', 'p1', ...], ['p0*', 'p1*', ...]`` for an operator
            acting on `n`>=2 sites.
            Strings (like ``'Id', 'Sz'``) are translated into single-site operators defined by
            :attr:`sites`.
        unitary : None | bool
            Whether `op` is unitary, i.e., whether the canonical form is preserved (``True``)
            or whether we should call :meth:`canonical_form` (``False``).
            ``None`` checks whether ``norm(op dagger(op) - identity)`` is smaller than `cutoff`.
        renormalize : bool
            Whether the final state should keep track of the norm (False, default), or
            the *change* of norm should be discarded (True).
        cutoff : float
            Cutoff for singular values if `op` acts on more than one site (see :meth:`from_full`).
            (And used as cutoff for a unspecified `unitary`.)
        understood_infinite : bool
            Raise a warning to make aware of :ref:`iMPSWarning`.
            Set ``understood_infinite=True`` to suppress the warning.
        """
        if not self.finite and not understood_infinite:
            warnings.warn("For infinite MPS, apply_local_op acts on *each* unit cell in parallel."
                          "See the warning in the docs of tenpy.networks.mps.")

        i = self._to_valid_index(i)
        if isinstance(op, str):
            op, need_JW = self.get_op([op], i)
            if need_JW:
                if self.bc == 'infinite':
                    raise ValueError("open JW string ending in each unit cell"
                                     "breaks translation invariance!")
                try:
                    JW_sign = self.apply_JW_string_left_of_virt_leg(self._B[i], 'vL', i)
                except ValueError as e:
                    raise ValueError(f"Would need JW string for operator {op!r}, "
                                     "but can't extract JW signs from the charges") from e
            opname = op
        else:
            opname = op
            need_JW = False
        n = op.rank // 2  # same as int(rank/2)
        if n == 1:
            pstar, p = 'p*', 'p'
        else:
            p = self._get_p_labels(n, False)
            pstar = self._get_p_labels(n, True)
        if unitary is None:
            op_op_dagger = npc.tensordot(op, op.conj(), axes=[pstar, p])
            if n > 1:
                op_op_dagger = op_op_dagger.combine_legs([p, pstar], qconj=[+1, -1])
            unitary = npc.norm(op_op_dagger - npc.eye_like(op_op_dagger)) < cutoff
        if n == 1:
            opB = npc.tensordot(op, self._B[i], axes=['p*', 'p'])
            self.set_B(i, opB, self.form[i])
            if opB.norm() < 1.e-12:
                raise ValueError(f"Applying the operator {opname!s} on site {i:d} destroys state!")
        else:
            th = self.get_theta(i, n)
            th = npc.tensordot(op, th, axes=[pstar, p])
            if th.norm() < 1.e-12:
                raise ValueError(f"Applying the operator {opname!s} on site {i:d} destroys state!")
            # use MPS.from_full to split the sites
            split_th = self.from_full(self.sites[i:i + n], th, None, cutoff, renormalize,
                                      'segment', (self.get_SL(i), self.get_SR(i + n - 1)))
            if not renormalize:
                self.norm *= split_th.norm
            for j in range(n):
                self.set_B(i + j, split_th._B[j], split_th.form[j])
            for j in range(n - 1):
                self.set_SR(i + j, split_th._S[j + 1])
        if not unitary:
            self.canonical_form(renormalize=renormalize)

    def apply_product_op(self, ops, unitary=None, renormalize=False):
        """Apply a (global) product of local onsite operators to `self`. In place.

        Note that this destroys the canonical form if any local operator is non-unitary.
        Therefore, this function calls :meth:`canonical_form` if necessary.

        The result is equivalent to the following loop, but more efficient by avoiding
        intermediate calls to :meth:`canonical_form` inside the loop::

            for i, op in enumerate(ops):
                self.apply_local_op(i, op, unitary, renormalize)

        .. warning ::
            This function does *not* automatically add Jordan-Wigner strings!
            For correct handling of fermions, use :meth:`apply_local_term` instead.

        Parameters
        ----------
        ops : (list of) str | npc.Array
            List of onsite operators to apply on each site, with legs ``'p', 'p*'``.
            Strings (like ``'Id', 'Sz'``) are translated into single-site operators defined by
            :attr:`sites`.
        unitary : None | bool
            Whether `op` is unitary, i.e., whether the canonical form is preserved (``True``)
            or whether we should call :meth:`canonical_form` (``False``).
            ``None`` checks whether ``max(norm(op dagger(op) - identity) for op in ops) < 1.e-14``
        renormalize : bool
            Whether the final state should keep track of the norm (False, default), or
            the *change* of norm should be discarded (True).
        """
        ops = to_iterable(ops)
        if self.L % len(ops) != 0:
            raise ValueError("len of ops incommensurate with self.L")
        self.convert_form('B')
        for i in range(self.L):
            op = ops[i % len(ops)]
            if isinstance(op, str):
                if op == 'Id':
                    continue  # nothing to do here...
                op = self.sites[i].get_op(op)
            if unitary is None:
                op_op_dagger = npc.tensordot(op, op.conj(), axes=['p*', 'p'])
                if npc.norm(op_op_dagger - npc.eye_like(op_op_dagger)) > 1.e-14:
                    unitary = False
            # actually apply the operator at site i
            self._B[i] = npc.tensordot(op, self._B[i], axes=['p*', 'p'])
        if not unitary:
            self.canonical_form(renormalize=renormalize)

    def apply_local_term(self,
                         term,
                         autoJW=True,
                         i_offset=0,
                         canonicalize=True,
                         renormalize=False):
        """Similar as :meth:`apply_local_op`, but for a whole `term` acting on multiple sites.

        Note that this destroys the canonical form if the local operator is non-unitary.
        Therefore, this function calls :meth:`canonical_form` by default.

        Parameters
        ----------
        term : list of (str, int)
            List of tuples ``op, i`` where `i` is the MPS index of the site the operator
            named `op` acts on.
            The order inside `term` determines the order in which they act
            (in the mathematical convention: the last operator in `term` is right-most,
            so it acts first on a ket).
        autoJW : bool
            If True (default), automatically insert Jordan Wigner strings for Fermions as needed.
        i_offset : int
            Offset to be added to the site-indices in the `term`.
        canonicalize : bool
            Whether to call :meth:`canonical_form` with the `renormalize` argument in the end.
        renormalize : bool
            Whether a change in the norm should be discarded (True),
            or used to update :attr:`norm` (False).
            Ignored if ``canonicalize=False``.
        """
        ops, i_min, has_extra_JW = self._term_to_ops_list(term, autoJW, i_offset, False)
        if has_extra_JW:
            if self.bc == 'infinite':
                raise ValueError("open JW string ending in each unit cell"
                                 "breaks translation invariance!")
            try:
                i = self._to_valid_index(i_min)
                self.apply_JW_string_left_of_virt_leg(self._B[i], 'vL', i)
            except ValueError as e:
                raise ValueError(f"Would need JW string for term {term!r}, "
                                 "but can't extract JW signs from the charges") from e
        for j, op in enumerate(ops):
            i = self._to_valid_index(j + i_min)  # i_min includes i_offset!
            opB = npc.tensordot(op, self._B[i], axes=['p*', 'p'])
            self.set_B(i, opB, self.form[i])
            if opB.norm() < 1.e-12:
                raise ValueError(f"Applying the operator on site {i:d} destroys state!")
        if canonicalize:
            self.canonical_form(renormalize=renormalize)

    def perturb(self, randomize_params=None, close_1=True, canonicalize=None):
        """Locally perturb the state a little bit; in place.

        Parameters
        ----------
        randomize_params : dict
            Parameters for the :class:`~tenpy.algorithms.tebd.RandomUnitaryEvolution`.
        close_1 : bool
            Select the default :cfg:option:`RandomUnitaryEvolution.distribution_func` to be used,
            if `close_1` is True, use :func:`~tenpy.linalg.random_matrix.U_close_1` for complex and
            :func:`~tenpy.linalg.random_matrix.O_close_1` for real MPS;
            for `close_1` False use :func:`~tenpy.linalg.random_matrix.CUE` or
            :func:`~tenpy.linalg.random_matrix.CRE`, respectively.
        canonicalize : bool
            Wether to call `psi.canonical_from in the end. Defaults to ``not close_1``.
        """
        from ..algorithms.tebd import RandomUnitaryEvolution
        if randomize_params is None:
            randomize_params = {}
        if close_1:
            func = 'U_close_1' if self.dtype.kind == 'c' else 'O_close_1'
        else:
            func = 'CUE' if self.dtype.kind == 'c' else 'CRE'
        randomize_params.setdefault('distribution_func', func)
        eng = RandomUnitaryEvolution(self, randomize_params)
        eng.run()
        if canonicalize is None:
            canonicalize = not close_1
        if canonicalize:
            self.canonical_form()
        # done

    def swap_sites(self, i, swap_op='auto', trunc_par=None):
        r"""Swap the two neighboring sites `i` and `i+1`; in place.

        Exchange two neighboring sites: form theta, 'swap' the physical legs and split
        with an svd. While the 'swap' is just a transposition/relabeling for bosons, one needs to
        be careful about the signs from Jordan-Wigner strings for fermions.

        Parameters
        ----------
        i : int
            Swap the two sites at positions `i` and `i+1`.
        swap_op : ``None`` | ``'auto', 'autoInv'`` | :class:`~tenpy.linalg.np_conserved.Array`
            The operator used to swap the physical legs of the two-site wave function `theta`.
            For ``None``, just transpose/relabel the legs.
            Alternative give an npc :class:`~tenpy.linalg.np_conserved.Array`
            which represents the full operator used for the swap.
            Should have legs ``['p0', 'p1', 'p0*', 'p1*']`` with ``'p0', 'p1*'`` contractible.
            For ``'auto'`` we try to be smart about fermionic signs, see note below.
        trunc_par : dict
            Parameters for truncation, see :cfg:config:`truncation`.

        Returns
        -------
        trunc_err : :class:`~tenpy.algorithms.truncation.TruncationError`
            The error of the represented state introduced by the truncation after the swap.

        Notes
        -----
        For fermions, it's crucial to use the correct `swap_op`.
        The `swap_op` is a two-site operator exchanging 'p0' and 'p1' legs.
        For bosons, this is really just a relabeling (done for ``swap_op=None``).
        Alternatively, you can construct the operator explicitly like this::

            siteL, siteR = psi.sites[i], psi.sites[i+1]
            dL, dR = siteL.dim, siteR.dim
            legL, legR = siteL.leg, siteR.leg
            swap_op_dense = np.eye(dL*dR)
            swap_op = npc.Array.from_ndarray(swap_op_dense.reshape([dL, dR, dL, dR]),
                                             [legL, legR, legL.conj(), legR.conj()],
                                             labels=['p1', 'p0', 'p0*', 'p1*'])

        However, for fermions we need to be very
        careful about the Jordan-Wigner strings. Let's derive how the operator should look like.

        You can write a state as

        .. math ::
            |\psi> = \sum_{[n_j]} \psi_{[n_j]} \prod_j (c^\dagger_j)^{n_j}  |vac>

        where ``[n_j]`` denotes a set of :math:`n_j \in [0, 1]` for
        each physical site `j` and the product over `j` is taken in increasing order.
        Let :math:`P` be the operator switching ``i <-> i+1``, with inverse :math:`P^\dagger`.
        Then:

        .. math ::
            P |\psi> = \sum_{[n_j]} \psi_{[n_i]} P \prod_j (c^\dagger_i)^{n_j} |vac> \\
                 = \sum_{[n_j]} \psi_{[n_i]} P \prod_j (c^\dagger_i)^{n_j}   |vac>

        When :math:`P` acts on the product of :math:`c^\dagger_{i}` operators,
        it commutes :math:`(c^\dagger_i)^{n_i}` with :math:`(c^\dagger_{i+1})^{n_{i+1}}`.
        This gives a a sign :math:`(-1)^{n_i * n_{i+1}}`. We must hence include this sign in
        the swap operator.
        The `n_i` in the equations above is given by :attr:`~tenpy.networks.site.JW_exponent`.
        This leads to the following swap operator used for fermions with ``swap_op='auto'``,
        suitable to just permute sites::

            siteL, siteR = psi.sites[i], psi.sites[i+1]
            dL, dR = siteL.dim, siteR.dim
            legL, legR = siteL.leg, siteR.leg
            n_i_n_j = np.outer(siteL.JW_exponent, siteR.JW_exponent).reshape(dL*dR)
            swap_op_dense = np.diag((-1)**n_i_n_j)
            swap_op = npc.Array.from_ndarray(swap_op_dense.reshape([dL, dR, dL, dR]),
                                             [legL, legR, legL.conj(), legR.conj()],
                                             labels=['p1', 'p0', 'p0*', 'p1*'])


        In some cases you might want to use a more complicated swap operator.
        As outlined in (the appendix of) :cite:`shapourian2017`, a typical hamiltonian of the form
        :math:`H = -t \sum_i c_i^\dagger c_{i+1} + h.c.  + \text{density interaction}`
        is invariant under a reflection :math:`R` acting as :math:`R c^e_x R^\dagger = i c^o_{-x}`
        and :math:`R c^o_x R^\dagger = i c^e_{-x}` for even/odd fermion sites.
        The following code includes the factor of :math:`i`,
        or rather :math:`-i` since we have creation operators, into the swap operator and is used
        with ``swap_op='autoInv'``::

            siteL, siteR = psi.sites[i], psi.sites[i+1]
            dL, dR = siteL.dim, siteR.dim
            legL, legR = siteL.leg, siteR.leg
            n_i = np.outer(siteL.JW_exponent, np.ones(dR)).reshape(dL*dR)
            n_j = np.outer(np.ones(dL), siteR.JW_exponent).reshape(dL*dR)
            swap_op_dense = np.diag((-1)**(n_i * n_j) * (-1.j)**n_i * (-1.j)**n_j)
            swap_op = npc.Array.from_ndarray(swap_op_dense.reshape([dL, dR, dL, dR]),
                                             [legL, legR, legL.conj(), legR.conj()],
                                             labels=['p1', 'p0', 'p0*', 'p1*'])

        """
        if trunc_par is None:
            trunc_par = {}
        siteL, siteR = self.sites[self._to_valid_index(i)], self.sites[self._to_valid_index(i + 1)]
        if isinstance(swap_op, str):
            dL, dR = siteL.dim, siteR.dim
            # site.JW_exponent is just the `n_i` in the equations of the note above.
            n_i = np.outer(siteL.JW_exponent, np.ones(dR)).reshape(dL * dR)
            n_j = np.outer(np.ones(dL), siteR.JW_exponent).reshape(dL * dR)
            if np.any(n_i * n_j):
                legL, legR = siteL.leg, siteR.leg
                if swap_op == 'auto':
                    swap_op_diag = (-1.)**(n_i * n_j)
                elif swap_op == 'autoInv':
                    swap_op_diag = (-1.)**(n_i * n_j) * (-1.j)**n_i * (-1.j)**n_j
                else:
                    raise ValueError("don't understand swap_op = " + repr(swap_op))
                legs = [siteL.leg, siteR.leg, siteL.leg.conj(), siteR.leg.conj()]
                swap_op = npc.Array.from_ndarray(np.diag(swap_op_diag).reshape([dL, dR, dL, dR]),
                                                 legs,
                                                 labels=['p1', 'p0', 'p0*', 'p1*'])
            else:  # at least one site isn't Fermions -> commutes
                swap_op = None  # continue with transposition as for Bosons
        theta = self.get_theta(i, n=2)
        C = self.get_theta(i, n=2, formL=0.)  # inversion free, see also TEBDEngine.update_bond()
        if swap_op is None:
            # just replace the labels, effectively this is a transposition.
            theta.ireplace_labels(['p0', 'p1'], ['p1', 'p0'])
            C.ireplace_labels(['p0', 'p1'], ['p1', 'p0'])
        elif isinstance(swap_op, npc.Array):
            theta = npc.tensordot(swap_op, theta, axes=[['p0*', 'p1*'], ['p0', 'p1']])
            C = npc.tensordot(swap_op, C, axes=(['p0*', 'p1*'], ['p0', 'p1']))
        else:
            raise ValueError("Invalid swap_op: got " + repr(swap_op))
        theta = theta.combine_legs([('vL', 'p0'), ('vR', 'p1')], qconj=[+1, -1])
        U, S, V, err, renormalize = svd_theta(theta, trunc_par, inner_labels=['vR', 'vL'])
        B_R = V.split_legs(1).ireplace_label('p1', 'p')
        B_L = npc.tensordot(C.combine_legs(('vR', 'p1'), pipes=theta.legs[1]),
                            V.conj(),
                            axes=['(vR.p1)', '(vR*.p1*)'])
        B_L.ireplace_labels(['vL*', 'p0'], ['vR', 'p'])
        B_L /= renormalize  # re-normalize to <psi|psi> = 1
        self.set_SR(i, S)
        self.set_B(i, B_L, 'B')
        self.set_B(i + 1, B_R, 'B')
        self.sites[self._to_valid_index(i)] = siteR  # swap 'sites' as well
        self.sites[self._to_valid_index(i + 1)] = siteL
        return err

    def permute_sites(self, perm, swap_op='auto', trunc_par=None, verbose=None):
        """Applies the permutation perm to the state; in place.

        .. deprecated :: 0.8.0
            Drop / ignore `verbose` argument, never print something.

        Parameters
        ----------
        perm : ndarray[ndim=1, int]
            The applied permutation, such that ``psi.permute_sites(perm)[i] = psi[perm[i]]``
            (where ``[i]`` indicates the `i`-th site).
        swap_op : ``None`` | ``'auto', 'autoInv'`` | :class:`~tenpy.linalg.np_conserved.Array`
            The operator used to swap the physical legs of a two-site wave function `theta`,
            see :meth:`swap_sites`.
        trunc_par : dict
            Parameters for truncation, see :cfg:config:`truncation`.

        Returns
        -------
        trunc_err : :class:`~tenpy.algorithms.truncation.TruncationError`
            The error of the represented state introduced by the truncation after the swaps.
        """
        if verbose is not None:
            warnings.warn("Dropped verbose argument", category=FutureWarning, stacklevel=2)
        perm = list(perm)  # gets modified, so we should copy
        # In order to keep sites close together, we always scan from the left,
        # keeping everything up to `i` in strictly ascending order.
        # => more or less an 'insertion' sort algorithm.
        # Works nicely for permutations like [1,2,3,0,6,7,8,5] (swapping the 0 and 5 around).
        # For [ 2 3 4 5 6 7 0 1], it splits 0 and 1 apart (first swapping the 0 down, then the 1)
        if trunc_par is None:
            trunc_par = asConfig({'chi_max': max(100, max(self.chi))}, 'trunc_params')
        trunc_err = TruncationError()
        num_swaps = 0
        i = 0
        while i < self.L - 1:
            if perm[i] > perm[i + 1]:
                trunc = self.swap_sites(i, swap_op, trunc_par)
                num_swaps += 1
                x, y = perm[i], perm[i + 1]
                perm[i + 1], perm[i] = x, y
                # restart from very left; but we know it's already sorted up to i-1
                if i > 0:
                    i -= 1
                trunc_err += trunc
            else:
                i += 1
        return trunc_err

    def compute_K(self,
                  perm,
                  swap_op='auto',
                  trunc_par=None,
                  canonicalize=1.e-6,
                  verbose=None,
                  expected_mean_k=0.):
        r"""Compute the momentum quantum numbers of the entanglement spectrum for 2D states.

        Works for an infinite MPS living on a cylinder, infinitely long in `x` direction and with
        periodic boundary conditions in `y` directions.
        If the state is invariant under 'rotations' around the cylinder axis, one can find the
        momentum quantum numbers of it. (The rotation is nothing more than a translation in `y`.)
        This function permutes some sites (on a copy of `self`) to enact the rotation, and then
        finds the dominant eigenvector of the mixed transfer matrix to get the quantum numbers,
        along the lines of :cite:`pollmann2012`, see also (the appendix and Fig. 11 in the arXiv
        version of) :cite:`cincio2013`.

        .. deprecated :: 0.8.0
            Drop / ignore `verbose` argument, never print something.

        Parameters
        ----------
        perm : 1D ndarray | :class:`~tenpy.models.lattice.Lattice`
            Permutation to be applied to the physical indices, see :meth:`permute_sites`.
            If a lattice is given, we use it to read out the lattice structure and shift
            each site by one lattice-vector in y-direction (assuming periodic boundary conditions).
            (If you have a :class:`~tenpy.models.model.CouplingModel`,
            give its `lat` attribute for this argument)
        swap_op : ``None`` | ``'auto', 'autoInv'`` | :class:`~tenpy.linalg.np_conserved.Array`
            The operator used to swap the physical legs of a two-site wave function `theta`,
            see :meth:`swap_sites`.
        trunc_par : dict
            Parameters for truncation, see :cfg:config:`truncation`.
        canonicalize : float
            Check that `self` is in canonical form; call :meth:`canonical_form`
            if :meth:`norm_test` yields ``np.linalg.norm(self.norm_test()) > canonicalize``.
        expected_mean_k : float
            As explained in :cite:`cincio2013`, the returned `W` is extracted as eigenvector of a
            mixed transfer matrix, and hence has an undefined phase. We fix the overall phase
            such that ``sum(s[j]**2 exp(iK[j]) == np.sum(W) = np.exp(1.j*expected_mean_k)``.

        Returns
        -------
        U : :class:`~tenpy.linalg.np_conserved.Array`
            Unitary representation of the applied permutation on left Schmidt states.
        W : ndarray
            1D array of the form ``S**2 exp(i K)``, where `S` are the Schmidt values
            on the left bond. You can use :func:`np.abs` and :func:`np.angle` to extract the
            (squared) Schmidt values `S` and momenta `K` from `W`.
        q : :class:`~tenpy.linalg.charges.LegCharge`
            LegCharge corresponding to `W`.
        ov : complex
            The eigenvalue of the mixed transfer matrix `<psi|T|psi>` per :attr:`L` sites.
            An absolute value different smaller than 1 indicates that the state is not invariant
            under the permutation or that the truncation error `trunc_err` was too large!
        trunc_err : :class:`~tenpy.algorithms.truncation.TruncationError`
            The error of the represented state introduced by the truncation after swaps when
            performing the truncation.
        """
        from ..models.lattice import Lattice  # dynamical import to avoid import loops
        if self.finite:
            raise ValueError("Works only for infinite b.c.")

        if isinstance(perm, Lattice):
            lat = perm
            assert lat.dim >= 2  # ensure that the lattice is at least 2D
            assert lat.N_sites == self.L
            shifted_lat_order = lat.order.copy()
            shifted_lat_order[:, 1] = np.mod(shifted_lat_order[:, 1] + 1, lat.Ls[1])
            perm = lat.lat2mps_idx(shifted_lat_order)
        # preliminary: check canonical form
        self.convert_form('B')
        norm_err = np.linalg.norm(self.norm_test())
        if norm_err > canonicalize:
            warnings.warn("self.norm_test() = {0!s} ==> canonicalize".format(self.norm_test()))
            self.canonical_form()
        # get copy of self
        psi_t = self.copy()
        # apply permutation
        perm = np.asarray(perm)
        trunc_err = psi_t.permute_sites(perm, swap_op, trunc_par)
        # re-check canonical form
        norm_err = np.linalg.norm(psi_t.norm_test())
        if norm_err > canonicalize:
            logger.warning("norm_error=%.10f after permutation: ==> canonicalize", norm_err)
        psi_t.convert_form('B')
        TM = TransferMatrix(self, psi_t, transpose=True, charge_sector=0)
        # Find left dominant eigenvector of this mixed transfer matrix.
        # Because we are in B form and get the left eigenvector,
        # the resulting vector should be sUs up to a scaling.
        ov, sUs = TM.eigenvectors(num_ev=self._transfermatrix_keep)
        if np.abs(ov[0]) < 0.9:
            logger.warning("compute_K: psi is not eigenvector of permutation/translation in y!"
                           f"expected |o| = 1., got |o| = {abs(ov[0]):.3e}\n")

        logger.info("compute_K: overlap %.5f, |o| = 1. - %.e5., trunc_err.eps=%.3e", ov[0],
                    1. - np.abs(ov[0]), trunc_err.eps)
        sUs = sUs[0].split_legs(0)
        _, sUs_blocked = sUs.as_completely_blocked()
        W = npc.eigvals(sUs_blocked, sort='m>')
        # W = s[j]^2 exp(i K[j]) up to overall scaling and phase
        # (as an eigenvector, sUS has arbitrary/unknown prefactor!)
        W = W / np.sum(np.abs(W))  # fix overall scaling by normalization np.sum(S[i]**2) == 1.
        mean_exp_ik = np.sum(W)
        if np.abs(mean_exp_ik) > 1.e-5:
            W *= np.conj(mean_exp_ik) / np.abs(mean_exp_ik)
        # Strip S's from U
        inv_S = 1. / self.get_SL(0)
        U = sUs.scale_axis(inv_S, 0).iscale_axis(inv_S, 1)  # note: U should commute with s
        # U should be unitary - rescale it such that norm(U)**2 = tr(U^dagger U) = chi
        U *= np.sqrt(U.shape[0]) / npc.norm(U)
        return U, W / np.sum(np.abs(W)), sUs_blocked.legs[0], ov[0], trunc_err

    def __str__(self):
        """Some status information about the MPS."""
        res = ["MPS, L={L:d}, bc={bc!r}.".format(L=self.L, bc=self.bc)]
        res.append("chi: " + str(self.chi))
        if self.L > 10:
            res.append("first two sites: " + repr(self.sites[0]) + " " + repr(self.sites[1]))
            res.append("first two forms:" + " ".join([repr(f) for f in self.form[:2]]))
        else:
            res.append("sites: " + " ".join([repr(s) for s in self.sites]))
            res.append("forms: " + " ".join([repr(f) for f in self.form]))
        return "\n".join(res)

    def compress(self, options):
        """Compress an MPS.

        Options
        -------
        .. cfg:config :: MPS_compress
            :include: VariationalCompression

            compression_method : ``'SVD' | 'variational'``
                Mandatory.
                Selects the method to be used for compression.
                For the `SVD` compression, `trunc_params` is the only other option used.
            trunc_params : dict
                Truncation parameters as described in :cfg:config:`truncation`.

        Returns
        -------
        max_trunc_err : :class:`~tenpy.algorithms.truncation.TruncationError`
            The maximal truncation error of a two-site wave function.
        """
        options = asConfig(options, "MPS_compress")
        method = options['compression_method']
        trunc_params = options.subconfig('trunc_params')
        if method == 'SVD':
            return self.compress_svd(trunc_params)
        elif method == 'variational':
            from ..algorithms.mps_common import VariationalCompression
            return VariationalCompression(self, options).run()
        raise ValueError("Unknown compression method: " + repr(method))

    def compress_svd(self, trunc_par):
        """Compress `self` with a single sweep of SVDs; in place.

        Perform a single right-sweep of QR/SVD without truncation, followed by a left-sweep with
        truncation, very much like :meth:`canonical_form_finite`.

        .. warning ::
            In case of a strong compression, this does not find the optimal, global solution.

        Parameters
        ----------
        trunc_par : dict
            Parameters for truncation, see :cfg:config:`truncation`.
        """
        trunc_err = TruncationError()
        if self.bc == 'finite':
            # Do QR starting from the left
            B = self.get_B(0, form='Th')
            for i in range(self.L - 1):
                B = B.combine_legs(['vL', 'p'])
                q, r = npc.qr(B, inner_labels=['vR', 'vL'])
                B = q.split_legs()
                self.set_B(i, B, form=None)
                B = self.get_B(i + 1, form='B')
                B = npc.tensordot(r, B, axes=('vR', 'vL'))
            # Do SVD from right to left & truncate
            for i in range(self.L - 1, 0, -1):
                B = B.combine_legs(['p', 'vR'])
                U, S, VH, err, norm_new = svd_theta(B, trunc_par)
                trunc_err += err
                self.norm *= norm_new
                VH = VH.split_legs()
                self.set_B(i, VH, form='B')
                B = self.get_B(i - 1, form=None)
                B = npc.tensordot(B, U, axes=('vR', 'vL'))
                B.iscale_axis(S, 'vR')
                self.set_SL(i, S)
            self.set_B(0, B, form='Th')
        elif self.bc == 'infinite':
            for i in range(self.L):
                theta = self.get_theta(i, n=2)
                theta = theta.combine_legs([['vL', 'p0'], ['p1', 'vR']], qconj=[+1, -1])
                self.set_svd_theta(i, theta, _machine_prec_trunc_par, update_norm=False)
            for i in range(self.L - 1, -1, -1):
                theta = self.get_theta(i, n=2)
                theta = theta.combine_legs([['vL', 'p0'], ['p1', 'vR']], qconj=[+1, -1])
                trunc_err += self.set_svd_theta(i, theta, trunc_par, update_norm=False)
        else:
            raise NotImplementedError("unsupported boundary conditions " + repr(self.bc))
        return trunc_err

    def _parse_form(self, form):
        """Parse `form` = (list of) {tuple | key of _valid_forms} to list of tuples"""
        if isinstance(form, tuple):
            return [form] * self.L
        form = to_iterable(form)
        if len(form) == 1:
            form = [form[0]] * self.L
        if len(form) != self.L:
            raise ValueError("Wrong len of `form`: " + repr(form))
        return [self._to_valid_form(f) for f in form]

    def _to_valid_form(self, form):
        """Parse `form` = {tuple | key of _valid_forms} to a tuple"""
        if isinstance(form, tuple):
            return form
        return self._valid_forms[form]

    def _scale_axis_B(self, B, S, form_diff, axis_B, cutoff):
        """Scale an axis of B with S to bring it in desired form.

        If S is just 1D (as usual, e.g. during TEBD), this function just performs
        ``B.scale_axis(S**form_diff, axis_B)``.

        However, during the DMRG with mixer, S might actually be a 2D matrix.
        For ``form_diff = -1``, we need to calculate the inverse of S, more precisely the
        (Moore-Penrose) pseudo inverse, see :func:`~tenpy.linalg.np_conserved.pinv`.
        The cutoff is only used in that case.

        Returns scaled B.
        """
        if form_diff == 0:
            return B  # nothing to do
        if not isinstance(S, npc.Array):
            # the usual case: S is a 1D array with singular values
            if form_diff == -1.:
                S = 1. / S
            elif form_diff != 1.:
                S = S**form_diff
            return B.scale_axis(S, axis_B)
        else:
            # e.g. during DMRG with a DensityMatrixMixer
            if S.rank != 2:
                raise ValueError("Expect 2D npc.Array or 1D numpy ndarray")
            if form_diff == -1:
                S = npc.pinv(S, cutoff)
            elif form_diff != 1.:
                raise ValueError("Can't scale/tensordot a 2D `S` for non-integer `form_diff`")

            # Hack: mpo.MPOEnvironment.full_contraction uses ``axis_B == 'vL*'``
            if axis_B == 'vL' or axis_B == 'vL*':
                B = npc.tensordot(S, B, axes=[1, axis_B]).replace_label(0, axis_B)
            elif axis_B == 'vR' or axis_B == 'vR*':
                B = npc.tensordot(B, S, axes=[axis_B, 0]).replace_label(-1, axis_B)
            else:
                raise ValueError("This should never happen: unexpected leg for scaling with S")
            return B

    def _canonical_form_dominant_gram_matrix(self, bond0, transpose, tol_xi, guess=None):
        """Find dominant eigenvector of the transfer matrix starting between sites (bond0-1,bond0).

        Find right (transpose=False) or left (transpose=True) eigenvector of the transfermatrix.
        """
        TM = TransferMatrix(self, self, bond0, bond0, transpose=transpose, charge_sector=0)
        if guess is None:
            diag = self.get_SL(bond0)**2 if transpose else 1.
            guess = TM.initial_guess(diag)
        guess = guess.combine_legs([0, 1], pipes=TM.pipe)
        eta, V = TM.eigenvectors(self._transfermatrix_keep, v0_npc=guess, which='LM')
        self._transfermatrix_keep = len(eta)
        if len(eta) > 1:
            if np.abs(eta[0]) > np.abs(eta[1]):
                xi = -self.L / np.log(np.abs((eta[1] / eta[0])))
            else:
                xi = np.inf
            if xi > tol_xi:
                raise ValueError("Degenerate spectrum of TransferMatrix "
                                 "(corr length xi={xi:.3e})".format(xi=xi))
        eta, G = eta[0], V[0]
        G = G.split_legs()
        # note: the dominant eigenvector should be hermitian and positive
        # removes phase (arbitrary for eigenvectors!) and normalize
        # right eigenvectors should have trace chi, left ones trace 1
        # (since we expect something close to eye(chi) for right and diag(S**2) for left G)
        norm = 1. if transpose else G.shape[0]
        G *= norm / npc.trace(G, 0, 1)
        if self.dtype.kind != 'c':  # psi is real -> G should be real
            eta = np.abs(eta)
            G.iunary_blockwise(np.real)
        return eta, G  # G has legs vL, vL* or vR, vR*

    def _canonical_form_correct_right(self, i1, Gr, eps=2. * np.finfo(np.double).eps):
        """Given the right gram matrix Gr, updated the bond (i0, i1), where i0 = i1 - 1.

        Diagonalize Gr = X^H Wr X and update
        ``B[i0] -> B[i0] X^H / norm``,
        ``B[i1] -> X B[i1] * norm``, where norm = sqrt(chi/sum(Wr)) == sqrt(chi/tr(Gr))
        If `Wr` has (almost) zero entries, reduce the bond dimension at the given bond.
        Then ``Gr -> Wr``.
        Return Wr normalized to ``sum(Wr) = chi``.
        """
        Gr.itranspose(['vL', 'vL*'])
        W, XH = npc.eigh(Gr)  # -> XH has legs vL vL* = vL vR
        if np.sign(W[np.argmax(np.abs(W))]) == -1:  # fix sign
            W = -W  # should actually never happen:  we initially normalize tr(Gr) = chi > 0
        # discard small values on order of machine precision
        proj = (W > eps)
        if np.count_nonzero(proj) < len(W):
            # project into non-degenerate subspace, reducing the bond dimensions!
            if np.count_nonzero(proj) < len(W) * 0.9:
                logger.warning("canonical_form_infinite: project to significantly smaller chi")
            XH.iproject(proj, axes=1)
            W = W[proj]
        norm = len(W) / np.sum(W)
        W *= norm
        norm = np.sqrt(norm)  # (norm doesn't change eigenvalue of TM)
        Kl = XH.iset_leg_labels(['vL', 'vR']) * (1. / norm)
        Kr = XH.transpose().iconj().iset_leg_labels(['vL', 'vR']) * norm
        i0 = i1 - 1
        self.set_B(i0, npc.tensordot(self.get_B(i0), Kl, axes=['vR', 'vL']))
        self.set_B(i1, npc.tensordot(Kr, self.get_B(i1), axes=['vR', 'vL']))
        return W, Kl, Kr

    def _canonical_form_correct_left(self, i1, Gl, Wr, eps=2. * np.finfo(np.double).eps):
        """Bring into canonical form on bond (i0, i1) where i0= i1 - 1.

        Given the left Gram matrix Gl (with legs 'vR*', 'vR')
        and right diag(Wr), compute and diagonalize the density matrix
        ``rho = sqrt(Wr) Gl sqrt(Wr) -> Y^H S^2 Y`` (Y acting on ket, Y^H on bra).
        Then we can update
        B[i0] -> B[i0] sqrt(Wr) Y^H
        B[i1] -> Y 1/sqrt(Wr) B[i1]
        Thus the new dominant left eigenvector is
        Gl -> Y sqrt(Wr) Gl sqrt(Wr) Y^H = S^2
        and dominant right eigenvector is
        diag(Wr) -> Y 1/sqrt(Wr) diag(Wr) 1/sqrt(W) Y^H = diag(1)
        i.e., we brought the bond to canonical form and `S` is the Schmidt spectrum.
        """
        sqrt_Wr = np.sqrt(Wr)
        Gl.itranspose(['vR*', 'vR'])
        rhor = Gl.scale_axis(sqrt_Wr, 0).iscale_axis(sqrt_Wr, 1)
        S2, YH = npc.eigh(rhor, sort='>')  # YH has legs 'vR*', 'vR'
        S2 /= np.sum(S2)  # equivalent to normalizing tr(rhor)=1
        s_norm = 1.
        # discard small values on order of machine precision
        proj = (S2 > eps)
        if np.count_nonzero(proj) < len(S2):
            # project into non-degenerate subspace, reducing the bond dimensions!
            if np.count_nonzero(proj) < len(S2) * 0.9:
                logger.warning("canonical_form_infinite: project to significantly smaller chi")
            YH.iproject(proj, axes=1)
            S2 = S2[proj]
            s_norm = np.sqrt(np.sum(S2))
        S = np.sqrt(S2) / s_norm
        self.set_SL(i1, S)
        Yl = YH.scale_axis(sqrt_Wr / s_norm, 0).iset_leg_labels(['vL', 'vR'])
        Yr = YH.transpose().iconj().scale_axis(1. / sqrt_Wr, 1).iset_leg_labels(['vL', 'vR'])
        i0 = i1 - 1
        self.set_B(i0, npc.tensordot(self.get_B(i0), Yl, axes=['vR', 'vL']))
        self.set_B(i1, npc.tensordot(Yr, self.get_B(i1), axes=['vR', 'vL']))
        Gl = npc.tensordot(Gl, Yl, axes=['vR', 'vL'])
        Gl = npc.tensordot(Yl.conj(), Gl, axes=['vL*', 'vR*'])  # labels 'vR*', 'vR'
        Gl /= npc.trace(Gl)
        # Gl is diag(S**2) up to numerical errors...
        return Gl, Yl, Yr

    def _gauge_compatible_vL_vR(self, other):
        """If necessary, gauge total charge of `other` to match the vL, vR legs of self.

        Returns a shallow copy where legs are adjusted.
        """
        if self.chinfo.qnumber == 0:
            return other
        need_gauge = (self.outer_virtual_legs() != other.outer_virtual_legs())
        if need_gauge:
            vL, vR = self.outer_virtual_legs()
            other = copy.copy(other)  # make shallow copy
            other._B = other._B[:]
            other.gauge_total_charge(None, vL, vR)
        return other

    def outer_virtual_legs(self):
        """Return the virtual legs on the left and right of the MPS.

        Returns
        -------
        vL, vR : :class:`~tenpy.linalg.charges.LegCharge`
            Outermost virtual legs of the MPS. Preserved for a segment MPS even when calling
            :meth:`canonical_form` on the segment.
        """
        U, V = self.segment_boundaries
        if U is not None:
            vL = U.get_leg('vL')
            vR = V.get_leg('vR')
        else:
            vL = self._B[0].get_leg('vL')
            vR = self._B[-1].get_leg('vR')
        return vL, vR

    def _get_bra_ket(self):
        return self, self

    def _normalize_exp_val(self, value):
        return np.real_if_close(value) # ignore self.norm

    def _contract_with_LP(self, C, i):
        C.ireplace_labels(['vL'], ['vR*'])
        return C

    def _contract_with_RP(self, C, i):
        C.ireplace_labels(['vR'], ['vL*'])
        return C


class BaseEnvironment(metaclass=ABCMeta):
    """Base class for :class:`MPSEnvironment` storing partial contractions between MPS.

    When `bra` and `ket` are the same, a suitable canonical form simplifies `LP` and `RP` tensors
    to identities, but for different `bra` and `ket`, or if we sandwich a whole MPO between the
    `bra` and `ket` (even if they are the same), the partial contractions are non-trivial.

    This class stores the partial contractions up to each bond.

    The MPS `bra` and `ket` have to be in canonical form.
    All the environments are constructed without the singular values on the open bond.
    In other words, we contract left-canonical `A` to the left parts `LP`
    and right-canonical `B` to the right parts `RP`.
    Thus, the special case ``ket=bra`` should yield identity matrices for `LP` and `RP`.

    Parameters
    ----------
    bra : :class:`~tenpy.networks.mps.MPS`
        The MPS to project on. Should be given in usual 'ket' form;
        we call `conj()` on the matrices directly.
        Stored in place, without making copies.
        If necessary to match charges, we call :meth:`~tenpy.networks.mps.MPS.gauge_total_charge`.
    ket : :class:`~tenpy.networks.mpo.MPO` | None
        The MPS on which the local operator acts.
        Stored in place, without making copies.
        If ``None``, use `bra`.
    cache : :class:`~tenpy.tools.cache.DictCache` | None
        Cache in which the tensors should be saved. If ``None``, a new `DictCache` is generated.
    **init_env_data :
        Further keyword arguments with initialization data, as returned by
        :meth:`get_initialization_data`.
        See :meth:`initialize_first_LP_last_RP` for details on these parameters.

    Attributes
    ----------
    sites : list of :class:`~tenpy.networks.site.Site`
        Defines the local Hilbert space for each site.
    L : int
        Number of physical sites involved into the Environment, i.e. the least common multiple
        of ``bra.L`` and ``ket.L``.
    bra, ket : :class:`~tenpy.networks.mps.MPS`
        The two MPS for the contraction.
    dtype : type
        The data type.
    finite : bool
        Whether the boundary conditions of the MPS are finite.
    cache : :class:`~tenpy.tools.cache.DictCache`
        Cache for saving the environment tensors.
    _LP_keys, _RP_keys : list of str
        Map indices to keys for the :attr:`cache`.
    _LP : list of {``None`` | }
        Left parts of the environment, len `L`.
        ``LP[i]`` contains the contraction strictly left of site `i`
        (or ``None``, if we don't have it calculated).
    _RP : list of {``None`` | :class:`~tenpy.linalg.np_conserved.Array`}
        Right parts of the environment, len `L`.
        ``RP[i]`` contains the contraction strictly right of site `i`
        (or ``None``, if we don't have it calculated).
    _LP_age : list of int | ``None``
        Used for book-keeping, how large the DMRG system grew:
        ``_LP_age[i]`` stores the number of physical sites involved into the contraction
        network which yields ``self.get_LP(i)``.
    _RP_age : list of int | ``None``
        Used for book-keeping, how large the DMRG system grew:
        ``_RP_age[i]`` stores the number of physical sites involved into the contraction
        network which yields ``self._RP[i]``.
    """

    def __init__(self, bra, ket, cache=None, **init_env_data):
        if ket is None:
            ket = bra
        if ket is not bra:
            bra = ket._gauge_compatible_vL_vR(bra)  # ensure matching charges
        self.bra = bra
        self.ket = ket
        self.dtype = np.promote_types(bra.dtype, ket.dtype)
        self.L = L = lcm(bra.L, ket.L)
        if hasattr(self, 'H'):
            self.L = L = lcm(self.H.L, L)
        self.finite = self.ket.finite  # just for _to_valid_index
        self.sites = self.ket.sites * (L // self.ket.L)
        self._LP_keys = ['LP_{0:d}'.format(i) for i in range(L)]
        self._RP_keys = ['RP_{0:d}'.format(i) for i in range(L)]
        self._LP_age = [None] * L
        self._RP_age = [None] * L
        if cache is None:
            cache = DictCache.trivial()
        self.cache = cache
        if not self.cache.long_term_storage.trivial and L < 8:
            warnings.warn("non-trivial cache for short-length environment: "
                          "Much overhead for a little RAM saving. Necessary?")
        self.init_first_LP_last_RP(**init_env_data)
        self.test_sanity()

    def init_first_LP_last_RP(self,
                              init_LP=None,
                              init_RP=None,
                              age_LP=0,
                              age_RP=0,
                              start_env_sites=0):
        """(Re)initialize first LP and last RP from the given data.

        Parameters
        ----------
        init_LP : ``None`` | :class:`~tenpy.linalg.np_conserved.Array`
            Initial very left part ``LP``. If ``None``, build one with :meth`init_LP`.
        init_RP : ``None`` | :class:`~tenpy.linalg.np_conserved.Array`
            Initial very right part ``RP``. If ``None``, build one with :meth:`init_RP`.
        age_LP : int
            The number of physical sites involved into the contraction of `init_LP`.
        age_RP : int
            The number of physical sites involved into the contraction of `init_RP`.
        start_env_sites : int
            If `init_LP` and `init_RP` are not specified, contract each `start_env_sites` for them.
        """
        init_LP, init_RP = self._check_compatible_legs(init_LP, init_RP, start_env_sites)
        ket_U, ket_V = self.ket.segment_boundaries
        bra_U, bra_V = self.bra.segment_boundaries
        if init_LP is None:
            init_LP = self.init_LP(0, start_env_sites)
            age_LP = start_env_sites
        else:
            if ket_U is not None:
                init_LP = npc.tensordot(init_LP, ket_U, axes=['vR', 'vL'])
            if bra_U is not None:
                init_LP = npc.tensordot(bra_U.conj(), init_LP, axes=['vL*', 'vR*'])
        if init_RP is None:
            init_RP = self.init_RP(self.L - 1, start_env_sites)
            age_RP = start_env_sites
        else:
            if ket_V is not None:
                init_RP = npc.tensordot(ket_V, init_RP, axes=['vR', 'vL'])
            if bra_V is not None:
                init_RP = npc.tensordot(init_RP, bra_V.conj(), axes=['vL*', 'vR*'])
        self.set_LP(0, init_LP, age=age_LP)
        self.set_RP(self.L - 1, init_RP, age=age_RP)

    def test_sanity(self):
        """Sanity check, raises ValueErrors, if something is wrong."""
        assert (self.bra.finite == self.ket.finite == self.finite)
        assert any(key in self.cache for key in self._LP_keys)
        assert any(key in self.cache for key in self._RP_keys)

    def _check_compatible_legs(self, init_LP, init_RP, start_env_sites):
        if init_LP is not None or init_RP is not None:
            if start_env_sites == 0:
                vL_ket, vR_ket = self.ket.outer_virtual_legs()
                vL_bra, vR_bra = self.bra.outer_virtual_legs()
            else:
                vL_ket = self.ket.get_B(-start_env_sites, 'A').get_leg('vL')
                vL_bra = self.bra.get_B(-start_env_sites, 'A').get_leg('vL')
                vR_ket = self.ket.get_B(self.L - 1 + start_env_sites, 'B').get_leg('vR')
                vR_bra = self.bra.get_B(self.L - 1 + start_env_sites, 'B').get_leg('vR')
        if init_LP is not None:
            compatible = (init_LP.get_leg('vR') == vL_ket.conj()
                          and init_LP.get_leg('vR*') == vL_bra)
            if not compatible:
                warnings.warn("dropping `init_LP` with incompatible MPS legs")
                init_LP = None
        if init_RP is not None:
            compatible = (init_RP.get_leg('vL') == vR_ket.conj()
                          and init_RP.get_leg('vL*') == vR_bra)
            if not compatible:
                warnings.warn("dropping `init_RP` with incompatible MPS legs")
                init_RP = None
        return init_LP, init_RP

    def init_LP(self, i, start_env_sites=0):
        """Build initial left part ``LP``.

        If `bra` and `ket` are the same and in left canonical form, this is the environment
        you get contracting the overlaps from the left infinity up to bond left of site `i`.

        For segment MPS, the :attr:`~tenpy.networks.mps.MPS.segment_boundaries` are read out
        (if set).

        Parameters
        ----------
        i : int
            Build ``LP`` left of site `i`.
        start_env_sites : int
            How many sites to contract to converge the `init_LP`; the initial `age_LP`.

        Returns
        -------
        init_LP : :class:`~tenpy.linalg.np_conserved.Array`
            Identity contractible with the `vL` leg of ``ket.get_B(i)``, labels ``'vR*', 'vR'``.
        """
        if self.ket.bc == "segment" and self.bra is not self.ket:
            U_bra, V_bra = self.bra.segment_boundaries
            U_ket, V_ket = self.ket.segment_boundaries
            if U_bra is not None or U_ket is not None:
                if U_bra is not None and U_ket is not None:
                    init_LP = npc.tensordot(U_bra.conj(), U_ket, axes=['vL*', 'vL'])
                elif U_bra is not None:
                    init_LP = U_bra.conj().ireplace_label('vL*', 'vR')
                else:
                    init_LP = U_ket.replace_label('vL', 'vR*')
                return init_LP
        leg_ket = self.ket.get_B(i - start_env_sites, None).get_leg('vL')
        leg_bra = self.bra.get_B(i - start_env_sites, None).get_leg('vL')
        leg_ket.test_equal(leg_bra)
        init_LP = npc.diag(1., leg_ket, dtype=self.dtype, labels=['vR*', 'vR'])
        for j in range(i - start_env_sites, i):
            init_LP = self._contract_LP(j, init_LP)
        return init_LP

    def init_RP(self, i, start_env_sites=0):
        """Build initial right part ``RP`` for an MPS/MPOEnvironment.

        If `bra` and `ket` are the same and in right canonical form, this is the environment
        you get contracting from the right infinity up to bond right of site `i`.

        For segment MPS, the :attr:`~tenpy.networks.mps.MPS.segment_boundaries` are read out
        (if set).

        Parameters
        ----------
        i : int
            Build ``RP`` right of site `i`.
        start_env_sites : int
            How many sites to contract to converge the `init_RP`; the initial `age_RP`.

        Returns
        -------
        init_RP : :class:`~tenpy.linalg.np_conserved.Array`
            Identity contractible with the `vR` leg of ``ket.get_B(i)``, labels ``'vL*', 'vL'``.
        """
        if self.ket.bc == "segment" and self.bra is not self.ket:
            U_bra, V_bra = self.bra.segment_boundaries
            U_ket, V_ket = self.ket.segment_boundaries
            if V_bra is not None or V_ket is not None:
                if V_bra is not None and V_ket is not None:
                    init_RP = npc.tensordot(V_bra.conj(), V_ket, axes=['vR*', 'vR'])
                elif V_bra is not None:
                    init_RP = V_bra.conj().ireplace_label('vR*', 'vL')
                else:
                    init_RP = V_ket.replace_label('vR', 'vL*')
                return init_RP
        leg_ket = self.ket.get_B(i + start_env_sites, None).get_leg('vR')
        leg_bra = self.bra.get_B(i + start_env_sites, None).get_leg('vR')
        leg_ket.test_equal(leg_bra)
        init_RP = npc.diag(1., leg_ket, dtype=self.dtype, labels=['vL*', 'vL'])
        for j in range(i + start_env_sites, i, -1):
            init_RP = self._contract_RP(j, init_RP)
        return init_RP

    def get_LP(self, i, store=True):
        """Calculate LP at given site from nearest available one.

        The returned ``LP_i`` corresponds to the following contraction,
        where the M's and the N's are in the 'A' form::

            |     .-------M[0]--- ... --M[i-1]--->-   'vR'
            |     |       |             |
            |     LP[0]   |             |
            |     |       |             |
            |     .-------N[0]*-- ... --N[i-1]*--<-   'vR*'

        Parameters
        ----------
        i : int
            The returned `LP` will contain the contraction *strictly* left of site `i`.
        store : bool
            Whether to store the calculated `LP` in `self` (``True``) or discard them (``False``).

        Returns
        -------
        LP_i : :class:`~tenpy.linalg.np_conserved.Array`
            Contraction of everything left of site `i`,
            with labels ``'vR*', 'vR'`` for `bra`, `ket`.
        """
        # find nearest available LP to the left.
        for i0 in range(i, i - self.L, -1):
            key = self._LP_keys[self._to_valid_index(i0)]
            LP = self.cache.get(key, None)
            if LP is not None:
                break
            # (for finite, LP[0] should always be set, so we should abort at latest with i0=0)
        else:  # no break called
            raise ValueError("No left part in the system???")
        age = self.get_LP_age(i0)
        for j in range(i0, i):
            LP = self._contract_LP(j, LP)
            age = age + 1
            if store:
                self.set_LP(j + 1, LP, age=age)
        return LP

    def get_RP(self, i, store=True):
        """Calculate RP at given site from nearest available one.

        The returned ``RP_i`` corresponds to the following contraction,
        where the M's and the N's are in the 'B' form::

            |     'vL'  ->---M[i+1]-- ... --M[L-1]----.
            |                |              |         |
            |                |              |         RP[L-1]
            |                |              |         |
            |     'vL*' -<---N[i+1]*- ... --N[L-1]*---.


        Parameters
        ----------
        i : int
            The returned `RP` will contain the contraction *strictly* right of site `i`.
        store : bool
            Whether to store the calculated `RP` in `self` (``True``) or discard them (``False``).

        Returns
        -------
        RP_i : :class:`~tenpy.linalg.np_conserved.Array`
            Contraction of everything left of site `i`,
            with labels ``'vL', 'vL*'`` for `ket`, `bra`.
        """
        # find nearest available RP to the right.
        for i0 in range(i, i + self.L):
            key = self._RP_keys[self._to_valid_index(i0)]
            RP = self.cache.get(key, None)
            if RP is not None:
                break
            # (for finite, RP[-1] should always be set, so we should abort at latest with i0=L-1)
        else:  # no break called
            raise ValueError("No right part in the system???")
        age = self.get_RP_age(i0)
        for j in range(i0, i, -1):
            RP = self._contract_RP(j, RP)
            age = age + 1
            if store:
                self.set_RP(j - 1, RP, age=age)
        return RP

    def get_LP_age(self, i):
        """Return number of physical sites in the contractions of get_LP(i).

        Might be ``None``.
        """
        return self._LP_age[self._to_valid_index(i)]

    def get_RP_age(self, i):
        """Return number of physical sites in the contractions of get_RP(i).

        Might be ``None``.
        """
        return self._RP_age[self._to_valid_index(i)]

    def set_LP(self, i, LP, age):
        """Store part to the left of site `i`."""
        i = self._to_valid_index(i)
        self.cache[self._LP_keys[i]] = LP
        self._LP_age[i] = age

    def set_RP(self, i, RP, age):
        """Store part to the right of site `i`."""
        i = self._to_valid_index(i)
        self.cache[self._RP_keys[i]] = RP
        self._RP_age[i] = age

    def del_LP(self, i):
        """Delete stored part strictly to the left of site `i`."""
        i = self._to_valid_index(i)
        del self.cache[self._LP_keys[i]]
        self._LP_age[i] = None

    def del_RP(self, i):
        """Delete stored part strictly to the right of site `i`."""
        i = self._to_valid_index(i)
        del self.cache[self._RP_keys[i]]
        self._RP_age[i] = None

    def clear(self):
        """Delete all partial contractions except the left-most `LP` and right-most `RP`."""
        for key in self._LP_keys[1:] + self._RP_keys[:-1]:
            if key in self.cache:
                del self.cache[key]
        self._LP_age[1:] = [None] * (self.L - 1)
        self._RP_age[:-1] = [None] * (self.L - 1)

    def has_LP(self, i):
        """Return True if `LP` left of site `i` is stored."""
        return self._LP_keys[self._to_valid_index(i)] in self.cache

    def has_RP(self, i):
        """Return True if `RP` right of site `i` is stored."""
        return self._RP_keys[self._to_valid_index(i)] in self.cache

    def cache_optimize(self, short_term_LP=[], short_term_RP=[], preload_LP=None, preload_RP=None):
        """Update `short_term_keys` for the cache and possibly preload tensors.

        Parameters
        ----------
        short_term_LP, short_term_RP : list of int
            `i` indices for :meth:`get_LP` and :meth:`get_RP`, respectively, for which a repeated
            look-up could happen, i.e., for which tensors should be kept in RAM until the next
            call to this function.
        preload_LP, preload_RP : int | None
            If not None, preload the tensors for the corresponding :meth:`get_LP` and :meth:`get_RP`
            call, respectively, from disk.
        """
        LP_keys = self._LP_keys
        RP_keys = self._RP_keys
        preload = []
        if preload_LP is not None:
            preload.append(LP_keys[self._to_valid_index(preload_LP)])
        if preload_RP is not None:
            preload.append(RP_keys[self._to_valid_index(preload_RP)])
        self.cache.set_short_term_keys(*(LP_keys[self._to_valid_index(i)] for i in short_term_LP),
                                       *(RP_keys[self._to_valid_index(i)] for i in short_term_RP),
                                       *preload)
        self.cache.preload(*preload)

    def get_initialization_data(self, first=0, last=None, include_bra=False, include_ket=False):
        """Return data for (re-)initialization of the environment.

        Parameters
        ----------
        first, last : int
            The first and last site, to the left and right of which we should return the
            environments.  Defaults to 0 and :attr:`L` - 1.
        include_bra, include_ket : bool
            Whether to also return the :attr:`bra` and :attr:`ket`, respectively.

        Returns
        -------
        init_env_data : dict
            A dictionary with the following entries.

            init_LP, init_RP : :class:`~tenpy.linalg.np_conserved.Array`
                `LP` on the left of site `first` and `RP` on the right of site `last`, which can be
                used as `init_LP` and `init_RP` for the initialization of a new environment.
            age_LP, age_RP : int
                The number of physical sites involved into the contraction yielding `init_LP` and
                `init_RP`, respectively.
            bra, ket : :class:`~tenpy.networks.mps.MPS`
                References of :attr:`bra` and :attr:`ket`.
                Only included if `include_bra` and `include_ket` are True, respectively.
        """
        if last is None:
            last = self.L - 1

        LP = self.get_LP(first, True)
        RP = self.get_RP(last, True)
        # possibly apply dagger of segment_boundaries to make sure it's possible to re-initialize
        # [TODO] I have no idea if this is correct, and I don't remember why I added this. - Sajant
        # If first != 0 or last != self.ket/bra.L, what happens to the boundaries?
        bra_U, bra_V = self.bra.segment_boundaries
        ket_U, ket_V = self.ket.segment_boundaries
        if first == 0:
            if ket_U is not None:
                LP = npc.tensordot(LP, ket_U.conj(), axes=['vR', 'vR*'])
                LP.ireplace_label('vL*', 'vR')
            if bra_U is not None:
                LP = npc.tensordot(bra_U, LP, axes=['vR', 'vR*'])
                LP.ireplace_label('vL', 'vR*')
        if last == self.ket.L - 1:
            if ket_V is not None:
                RP = npc.tensordot(ket_V.conj(), RP, axes=['vL*', 'vL'])
                RP.ireplace_label('vR*', 'vL')
        if last == self.bra.L - 1:
            if bra_V is not None:
                RP = npc.tensordot(RP, bra_V, axes=['vL*', 'vL'])
                RP.ireplace_label('vR', 'vL*')
        data = {
            'init_LP': LP,
            'age_LP': self.get_LP_age(first),
            'init_RP': RP,
            'age_RP': self.get_RP_age(last),
        }

        if include_bra:
            data['bra'] = self.bra
        if include_ket:
            data['ket'] = self.ket

        """
        # Original code
        data = {'init_LP': self.get_LP(first, True), 'init_RP': self.get_RP(last, True)}
        data['age_LP'] = self.get_LP_age(first)
        data['age_RP'] = self.get_RP_age(last)
        if include_bra:
            data['bra'] = self.bra
        if include_ket:
            data['ket'] = self.ket
        """
        return data

    @abstractmethod
    def full_contraction(self, i0):
        """Calculate the overlap by a full contraction of the network.

        This function contracts ``get_LP(i0+1, store=False)`` and ``get_RP(i0, store=False)``
        with appropriate singular values in between.

        Conventions for :class:`MPSEnvironment` and :class:`~tenpy.networks.mpo.MPOEnvironment`
        are slightly different: the `MPSEnvironment` multiplies with
        taking into account :attr:`MPS.norm` of both `bra` and `ket`, the MPOEnvironment not.

        Parameters
        ----------
        i0 : int
            Site index.
        """
        ...  # can use _full_contraction_LP_RP

    def _full_contraction_LP_RP(self, i0):
        if self.ket.finite and i0 + 1 == self.L:
            # special case to handle `_to_valid_index` correctly:
            # get_LP(L) is not valid for finite b.c, so we use need to calculate it explicitly.
            LP = self.get_LP(i0, store=False)
            LP = self._contract_LP(i0, LP)
        else:
            LP = self.get_LP(i0 + 1, store=False)
        # multiply with `S` on bra and ket side
        S_bra = self.bra.get_SR(i0).conj()
        if isinstance(S_bra, npc.Array):
            LP = npc.tensordot(S_bra, LP, axes=['vL*', 'vR*'])
        else:
            LP = LP.scale_axis(S_bra, 'vR*')
        S_ket = self.ket.get_SR(i0)
        if isinstance(S_ket, npc.Array):
            LP = npc.tensordot(LP, S_ket, axes=['vR', 'vL'])
        else:
            LP = LP.scale_axis(S_ket, 'vR')
        RP = self.get_RP(i0, store=False)
        return LP, RP

    @abstractmethod
    def _contract_LP(self, i, LP):
        """Contract LP with the tensors on site `i` to form ``self.get_LP(i+1)``"""
        ...

    @abstractmethod
    def _contract_RP(self, i, RP):
        """Contract RP with the tensors on site `i` to form ``self.get_RP(i-1)``"""
        ...


class MPSEnvironment(BaseEnvironment, BaseMPSExpectationValue):
    """Class storing partial contractions between two different MPS and providing expectation values.

    The network for a contraction :math:`<bra|Op|ket>` of a local operator `Op`, say exemplary
    at sites `i, i+1` looks like::

        |     .-----M[0]--- ... --M[1]---M[2]--- ... ->--.
        |     |     |             |      |               |
        |     |     |             |------|               |
        |     LP[0] |             |  Op  |               RP[-1]
        |     |     |             |------|               |
        |     |     |             |      |               |
        |     .-----N[0]*-- ... --N[1]*--N[2]*-- ... -<--.

    This class stores the partial contractions `LP` and `RP` coming from the left and right up to
    each bond, allowing efficient calculations of expectation values, correlation functions etc.

    We use the following label convention (where arrows indicate `qconj`)::

        |    .-->- vR           vL ->-.
        |    |                        |
        |    LP                       RP
        |    |                        |
        |    .--<- vR*         vL* -<-.

    """

    def full_contraction(self, i0):
        """Calculate the overlap by a full contraction of the network.

        The full contraction of the environments gives the overlap ``<bra|ket>``,
        taking into account the :attr:`MPS.norm` of both `bra` and `ket`.
        For this purpose, this function contracts ``get_LP(i0+1, store=False)`` and
        ``get_RP(i0, store=False)`` with appropriate singular values in between.

        Parameters
        ----------
        i0 : int
            Site index.
        """
        LP, RP = self._full_contraction_LP_RP(i0)
        contr = npc.inner(LP, RP, axes=[['vR*', 'vR'], ['vL*', 'vL']], do_conj=False)
        return contr * self.bra.norm * self.ket.norm

    def _contract_LP(self, i, LP):
        LP = npc.tensordot(LP, self.ket.get_B(i, form='A'), axes=('vR', 'vL'))
        axes = (self.ket._get_p_label('*') + ['vL*'], self.ket._p_label + ['vR*'])
        # for a usual MPS, axes = (['p*', 'vL*'], ['p', 'vR*'])
        LP = npc.tensordot(self.bra.get_B(i, form='A').conj(), LP, axes=axes)
        return LP  # labels 'vR*', 'vR'

    def _contract_RP(self, i, RP):
        RP = npc.tensordot(self.ket.get_B(i, form='B'), RP, axes=('vR', 'vL'))
        axes = (self.ket._p_label + ['vL*'], self.ket._get_p_label('*') + ['vR*'])
        # for a usual MPS, axes = (['p', 'vL*'], ['p*', 'vR*'])
        RP = npc.tensordot(RP, self.bra.get_B(i, form='B').conj(), axes=axes)
        return RP  # labels 'vL', 'vL*'

    # methods for Expectation values
    def _get_bra_ket(self):
        return self.bra, self.ket

    def _normalize_exp_val(self, value):
        # this ensures that
        #     MPSEnvironment(psi, psi.apply_local_op('B', i)).expectation_value('A', j)
        # gives the same as
        #     psi.correlation_function('A', 'B', sites1=[i], sites2=[j])
        # and psi.apply_local_op('Adagger', i).overlap(psi.apply_local_op('B', j)
        # for initially normalized psi
        return np.real_if_close(value) * (self.bra.norm * self.ket.norm)

    def _contract_with_LP(self, C, i):
        LP = self.get_LP(i, store=True)
        C = npc.tensordot(LP, C, axes=['vR', 'vL'])  # axes_p + (vR*, vR)
        return C

    def _contract_with_RP(self, C, i):
        RP = self.get_RP(i, store=True)
        C = npc.tensordot(C, RP, axes=['vR', 'vL'])  # axes_p + (vL, vL*)
        return C

    def _update_gauge_LP(self, i, U, update_bra, update_ket):
        """Update LP[i] following the MPS gauge ``A[i-1] A[i] -> (A[i-1] U) (Udagger A[i])``."""
        assert update_bra or update_ket
        if not self.has_LP(i):
            return
        LP = self.get_LP(i)
        if update_ket:
            LP = npc.tensordot(LP, U, axes=['vR', 'vL'])
        if update_bra:
            LP = npc.tensordot(U.conj(), LP, axes=['vL*', 'vR*'])
        self.set_LP(i, LP, self.get_LP_age(i))

    def _update_gauge_RP(self, i, V, update_bra, update_ket):
        """Update RP[i] following the MPS gauge ``B[i] B[i+1] -> (B[i] Vdagger) (V B[i+1])``."""
        assert update_bra or update_ket
        if not self.has_RP(i):
            return
        RP = self.get_RP(i)
        if update_ket:
            RP = npc.tensordot(V, RP, axes=['vR', 'vL'])
        if update_bra:
            RP = npc.tensordot(RP, V.conj(), axes=['vL*', 'vR*'])
        self.set_RP(i, RP, self.get_RP_age(i))


class TransferMatrix(sparse.NpcLinearOperator):
    r"""Transfer matrix of two MPS (bra & ket).

    For an iMPS in the thermodynamic limit, we often need to find the 'dominant `RP`' (and `LP`).
    This mean nothing else than to take the transfer matrix of the unit cell and find the
    (right/left) eigenvector with the largest (magnitude) eigenvalue, since it will dominate
    :math:`(TM)^n RP` (or :math:`LP (TM)^n`) in the limit :math:`n \rightarrow \infty` - whatever
    the initial `RP` is. This class provides exactly that functionality with :meth:`eigenvectors`.

    Given two MPS, we define the transfer matrix as::

        |    ---M[i]---M[i+1]- ... --M[i+L]---
        |       |      |             |
        |    ---N[j]*--N[j+1]* ... --N[j+L]*--

    Here the `N` denotes the matrices of the bra and `M` the ones of the ket, respectively.
    To view it as a `matrix`, we combine the left and right indices to pipes::

        |  (vL.vL*) ->-TM->- (vR.vR*)   acting on  (vL.vL*) ->-RP

    Note that we keep all M and N as copies.

    .. deprecated :: 0.6.0
        The default for `shift_ket` was the value of `shift_bra`, this will be changed to 0.

    Parameters
    ----------
    bra : MPS
        The MPS which is to be (complex) conjugated.
    ket : MPS
        The MPS which is not (complex) conjugated.
    shift_bra : int
        We start the `N` of the bra at site `shift_bra` (i.e. the `j` in the above network).
    shift_ket : int | None
        We start the `M` of the ket at site `shift_ket` (i.e. the `i` in the above network).
        ``None`` is deprecated, default will be changed to 0 in the future.
    transpose : bool
        Whether `self.matvec` acts on `RP` (``False``) or `LP` (``True``).
    charge_sector : None | charges | ``0``
        Selects the charge sector of the vector onto which the Linear operator acts.
        ``None`` stands for *all* sectors, ``0`` stands for the zero-charge sector.
        Defaults to ``0``, i.e., **assumes** the dominant eigenvector is in charge sector 0.
        Note that you can update the `charge_sector` after initialization
        via the :attr:`charge_sector` property.
    form : ``'B' | 'A' | 'C' | 'G' | 'Th' | None`` | tuple(float, float)
        In which canonical form we take the `M` and `N` matrices.


    Attributes
    ----------
    L : int
        Number of physical sites involved in the transfer matrix, i.e. the least common multiple
        of `bra.L` and `ket.L`.
    shift_bra : int
        We start the `N` of the bra at site `shift_bra`.
    shift_ket : int | None
        We start the `M` of the ket at site `shift_ket`. ``None`` defaults to `shift_bra`.
    transpose : bool
        Whether `self.matvec` acts on `RP` (``True``) or `LP` (``False``).
    qtotal : charges
        Total charge of the transfer matrix (which is gauged away in matvec).
    form : tuple(float, float) | None
        In which canonical form (all of) the `M` and `N` matrices are.
    flat_linop : :class:`~tenpy.linalg.sparse.FlatLinearOperator`
        Class lifting :meth:`matvec` to ndarrays in order to use :func:`~tenpy.tools.math.speigs`.
    pipe : :class:`~tenpy.linalg.charges.LegPipe`
        Pipe corresponding to ``'(vL.vL*)'`` for ``transpose=False``
        or to ``'(vR.vR*)'`` for ``transpose=True``.
    label_split :
        ``['vL', 'vL*']`` if ``transpose=False`` or ``['vR', 'vR*']`` if ``transpose=True``.
    _bra_N : list of npc.Array
        Complex conjugated matrices of the bra, transposed for fast `matvec`.
    _ket_M : list of npc.Array
        The matrices of the ket, transposed for fast `matvec`.
    """

    def __init__(self,
                 bra,
                 ket,
                 shift_bra=0,
                 shift_ket=None,
                 transpose=False,
                 charge_sector=0,
                 form='B'):
        L = lcm(bra.L, ket.L)
        if ket.chinfo != bra.chinfo:
            raise ValueError("incompatible charges")
        if shift_ket is None:
            if shift_bra != 0:
                warnings.warn("default for shift_ket will change to 0. Specify both explicitly!",
                              FutureWarning, 2)
            shift_ket = shift_bra
        self.shift_bra = shift_bra
        self.shift_ket = shift_ket
        assert ket._p_label == bra._p_label
        form = ket._to_valid_form(form)
        ket_M = [ket.get_B(i, form=form) for i in range(shift_ket, shift_ket + L)]
        bra_N = [bra.get_B(i, form=form) for i in range(shift_bra, shift_bra + L)]

        self._init_from_Ns_Ms(bra_N, ket_M, transpose, charge_sector, ket._p_label, not ket.finite)

    def _init_from_Ns_Ms(self, bra_N, ket_M, transpose, charge_sector, p_label, infinite=True):
        """Initialize directly from N and M.

        bra_N and ket_M are *not* reversed for transpose=False, i.e. ordered left to right.
        """
        self.L = len(bra_N)
        assert len(ket_M) == self.L
        self.transpose = transpose
        self._p_label = p = p_label  # for usual MPS just ['p']
        self._pstar_label = pstar = [lbl + '*' for lbl in self._p_label]
        if not transpose:  # right to left
            label = '(vL.vL*)'  # what we act on
            label_split = ['vL', 'vL*']
            M = self._ket_M = [B.itranspose(['vL'] + p + ['vR']) for B in reversed(ket_M)]
            N = self._bra_N = [
                B.conj().itranspose(pstar + ['vR*', 'vL*']) for B in reversed(bra_N)
            ]
            pipe = npc.LegPipe([M[0].get_leg('vR'), N[0].get_leg('vR*')], qconj=-1).conj()
        else:  # left to right
            label = '(vR*.vR)'  # mathematically more natural
            label_split = ['vR*', 'vR']
            M = self._ket_M = [B.itranspose(['vL'] + p + ['vR']) for B in ket_M]
            N = self._bra_N = [B.conj().itranspose(['vR*', 'vL*'] + pstar) for B in bra_N]
            pipe = npc.LegPipe([N[0].get_leg('vL*'), M[0].get_leg('vL')], qconj=+1).conj()
        dtype = np.promote_types(M[0].dtype, N[0].dtype)
        self.pipe = pipe
        self.label_split = label_split
        self.flat_linop = sparse.FlatLinearOperator(self.matvec, pipe, dtype, charge_sector, label)
        chinfo = M[0].chinfo
        self.qtotal = chinfo.make_valid(np.sum([B.qtotal for B in M + N], axis=0))
        if infinite and np.any(self.qtotal != 0):
            # for non-zero U(1) qtotal, we can immediately say that `self` is nilpotent.
            # In contrast, nonzero Z_N qtotal does not imply that, since the transfer-matrix
            # doesn't have to be hermitian: it could be circulant, with arbitrary eigenvalues!
            # The eigenvectors will *not* conserve the charge in this case!
            enlarge_factors = []
            for i in np.nonzero(self.qtotal)[0]:
                if chinfo.mod[i] == 1:  # U(1) qtotal
                    raise ValueError("TransferMatrix is nil-potent due to charges")
                enlarge_factors.append(chinfo.mod[i])  # get N of Z_N charge
            raise ValueError("TransferMatrix has non-zero qtotal for Z_N charges. "
                             "It can have valid eigenvectors, but they will break the Z_N charge. "
                             "To avoid that, you can enlarge the unit cell of the MPS "
                             "by a factor of " + str(enlarge_factors))

    @classmethod
    def from_Ns_Ms(cls, bra_N, ket_M, transpose=False, charge_sector=0, p_label=['p']):
        """Initialize a TransferMatrix directly from the MPS tensors.

        Parameters
        ----------
        bra_N, ket_M : list of :class:`~tenpy.linalg.np_conserved.Array`
            Plain tensors of the bra and ket, in a list going left to right,
            the bra not conjugated.
        transpose : bool
            Whether `self.matvec` acts on `RP` (``False``) or `LP` (``True``).
        charge_sector : None | charges | ``0``
            Selects the charge sector of the vector onto which the Linear operator acts.
            ``None`` stands for *all* sectors, ``0`` stands for the zero-charge sector.
            Defaults to ``0``, i.e., **assumes** the dominant eigenvector is in charge sector 0.
        p_label : list of str
            Physical label(s) of the tensors.
        """
        self = cls.__new__(cls)
        self.shift_bra = self.shift_ket = 0
        self._init_from_Ns_Ms(bra_N, ket_M, transpose, charge_sector, p_label)
        return self

    @property
    def charge_sector(self):
        return self.flat_linop.charge_sector

    @charge_sector.setter
    def charge_sector(self, value):
        self.flat_linop.charge_sector = value

    def matvec(self, vec):
        """Given `vec` as an npc.Array, apply the transfer matrix.

        Parameters
        ----------
        vec : :class:`~tenpy.linalg.np_conserved.Array`
            Vector to act on with the transfermatrix.
            If not `transposed`, `vec` is the right part `RP` of an environment,
            with legs ``'(vL.vL*)'`` in a pipe or splitted.
            If `transposed`, the left part `LP` of an environment with legs ``'(vR*.vR)'``.

        Returns
        -------
        mat_vec : :class:`~tenpy.linalg.np_conserved.Array`
            The transfer matrix acted on `vec`, in the same form as given.
        """
        pipe = None
        if self.label_split[0] not in vec._labels:
            vec = vec.split_legs(0)
            pipe = self.pipe
        orig_labels = vec.get_leg_labels()
        # vec.itranspose(self.label_split)  # ['vL', 'vL*'] or ['vR*', 'vR']
        qtotal = vec.qtotal
        legs = vec.legs
        # the actual work
        if not self.transpose:  # right to left
            contract = [self._p_label + ['vL*'], self._pstar_label + ['vR*']]
            for N, M in zip(self._bra_N, self._ket_M):
                vec = npc.tensordot(M, vec, axes=['vR', 'vL'])
                vec = npc.tensordot(vec, N, axes=contract)  # [['p', 'vL*'], ['p*', 'vR*']]
        else:  # left to right
            contract = [['vL*'] + self._pstar_label, ['vR*'] + self._p_label]
            for N, M in zip(self._bra_N, self._ket_M):
                vec = npc.tensordot(vec, M, axes=['vR', 'vL'])
                vec = npc.tensordot(N, vec, axes=contract)  # [['vL*', 'p*'], ['vR*', 'p']])
        if pipe is None:
            vec.itranspose(orig_labels)  # make sure we have the same labels/order as before
        else:
            vec = vec.combine_legs(self.label_split, pipes=pipe)
        return vec

    def initial_guess(self, diag=1.):
        """Return a diagonal matrix as initial guess for the eigenvector.

        Parameters
        ----------
        diag : float | 1D ndarray
            Should be ``1.`` for the identity or some singular values squared.

        Returns
        -------
        mat : :class:`~tenpy.linalg.np_conserved.Array`
            A 2D array with `diag` on the diagonal such that :meth:`matvec` can act on it.
        """
        return npc.diag(diag, self.pipe.legs[0], labels=self.label_split)

    def eigenvectors(self, *args, **kwargs):
        """Find (dominant) eigenvector(s) of self using :mod:`scipy.sparse`.

        For arguments see :meth:`~tenpy.linalg.sparse.FlatLinearOperator.eigenvectors`.

        If no :attr:`charge_sector` was selected, we look in *all* charge sectors.
        The returned eigenvectors have combined legs ``'(vL.vL*)'`` or ``(vR*.vR)``.
        """
        return self.flat_linop.eigenvectors(*args, **kwargs)


class InitialStateBuilder:
    """Class to simplify providing common sets of initial states.

    This class is used by the :class:`~tenpy.simulations.simulation.Simulation` to initialize MPS.
    The idea is that you can fully specify the initial state by a few parameters and possibly
    a custom function (by inheriting from this class), as demonstrated in the examples below.

    Parameters
    ----------
    lattice : :class:`~tenpy.models.lattice.Lattice`
        The lattice class defining the geometry and sites.
    options : dict
        Parameter dictionary which specifies the initial state to be generated.
    model_dtype : :class:`numpy.dtype`
        Data type of the model hamiltonian, default for the dtype of the resulting `psi`.

    Options
    -------
    .. cfg:config :: InitialStateBuilder

        method : str
            Selects the category of the initial state, and in particular the
            name of the method called by :meth:`build` to generate the state, for example you can
            set ``method='lat_product_state'`` to use :meth:`lat_product_state`.
            The available other parameters depend on the chosen method.

    Examples
    --------
    If you use the :class:`~tenpy.simulations.simulation.Simulation` setup, it will extract
    the `lattice` and `model_dtype` from the :attr:`~tenpy.models.model.Model.lat` and MPO dtype.
    Let's assume that we have a lattice `lat` with :class:`~tenpy.networks.site.SpinHalfSite`
    on a square lattices. Then you could initialize a Neel state like this:

    .. testsetup :: InitialStateBuilder

        from tenpy.networks.mps import InitialStateBuilder
        import tenpy
        spin_half = tenpy.networks.site.SpinHalfSite(conserve=None)
        lat = tenpy.models.lattice.Square(4, 4, spin_half)

    .. doctest :: InitialStateBuilder

        >>> options = {'method': 'lat_product_state',
        ...            'product_state' : [[['up'], ['down']],
        ...                               [['down'], ['up']]],
        ...            }
        >>> psi = InitialStateBuilder(lat, options).run()

    Note that the `method` options is mandatory, it selects which other method :meth:`run` calls.
    This allows to define custom initial states with the same interface by defining your own
    subclass, e.g. to get a short-hand for the Neel state:

    .. doctest :: InitialStateBuilder

        >>> class MyInitialStateBuilderForSquare(InitialStateBuilder):
        ...     def neel(self):
        ...         # my_option = self.options.get('opt_name', default) # not necessary here
        ...         product_state = [[['up'], ['down']], [['down'], ['up']]]
        ...         return self.lat_product_state(product_state)
        >>> options = {'method': 'neel'}
        >>> psi = MyInitialStateBuilderForSquare(lat, options).run()

    If you define such a custom class, you can activate it in simulations by explicitly setting
    the :cfg:option:`Simulation.initial_state_builder_class` to the name of it.
    """

    #: logger : An instance of a logger; see :doc:`/intro/logging`. NB: class attribute.
    logger = logging.getLogger(__name__ + '.InitialStateBuilder')

    def __init__(self, lattice, options, model_dtype=np.float64):
        self.lattice = lattice
        self.options = asConfig(options, self.__class__.__name__)
        self.model_dtype = model_dtype

    def run(self):
        """Build an initial state from a specified method.

        Reads out the option :cfg:option:`InitialStateBuilder.method` to choose a method of the
        class which generates the state.

        Returns
        -------
        psi : :class:`MPS`
            The generated MPS.
        """
        method_name = self.options['method']
        method = getattr(self, method_name, None)
        if method is None:
            raise ValueError(f"initial state 'method'={method_name!r} not recognized in " +
                             self.__class__.__name__)
        self.logger.info("calling %s.%s()", self.__class__.__name__, method_name)
        psi = method()
        self.check_total_charge(psi)
        return psi

    def check_total_charge(self, psi):
        """Assert that the given state has the expected charge.

        Parameters
        ----------
        psi : :class:`MPS`
            The final, generated state.

        .. cfg:configoptions :: InitialStateBuilder

            check_total_charge : tuple of int
                Check that the :meth:`MPS.get_total_charge` returns these values.
        """
        check_charge = self.options.get('check_global_charge', None)
        if check_charge is None:
            return
        check_charge = tuple(check_charge)
        has_charge = tuple(psi.get_total_charge(psi.bc == 'finite'))
        assert check_charge == has_charge

    def from_file(self):
        """Load the initial state from an existing file.

        Options
        -------
        .. cfg:configoptions :: InitialStateBuilder

            filename : str
                The filename from which to load the state
            data_key : str
                Key within the file to be used for loading the data.
                Can be recursive (separated by '/'), see :func:`tenpy.tools.misc.get_recursive`.
        """
        filename = self.options['filename']
        data_key = self.options.get('data_key', "psi")
        self.logger.info("loading initial state from %r, key %r", filename, data_key)
        if filename.endswith('.h5') or filename.endswith('.hdf5'):
            with hdf5_io.h5py.File(filename, 'r') as f:
                psi = hdf5_io.load_from_hdf5(f, data_key)
        else:
            data = hdf5_io.load(filename)
            psi = get_recursive(data, data_key, separator='/')
        psi.test_sanity()
        return psi

    def lat_product_state(self, p_state=None):
        """Initialize from a lattice product state.

        See :meth:`MPS.from_lat_product_state` for details.

        Options
        -------
        .. cfg:configoptions :: InitialStateBuilder

            product_state : array of str
                The `p_state` passed on to :meth:`MPS.from_lat_product_state`.
            allow_incommensurate : bool
                See :meth:`MPS.from_lat_product_state`.
        """
        if p_state is None:
            p_state = self.options['product_state']
        self.check_filling(p_state)
        dtype = self.options.get('dtype', self.model_dtype)
        allow_incommensurate = self.options.get('allow_incommensurate', False)
        psi = MPS.from_lat_product_state(self.lattice, p_state, dtype=dtype,
                                         allow_incommensurate=allow_incommensurate)
        return psi

    def mps_product_state(self, p_state=None):
        """Initialize from a product state.

        See :meth:`MPS.from_product_state` for details.

        Options
        -------
        .. cfg:configoptions :: InitialStateBuilder

            product_state : list of str
                The `p_state` passed on to :meth:`MPS.from_product_state`.
        """
        if p_state is None:
            p_state = self.options['product_state']
        self.check_filling(p_state)
        dtype = self.options.get('dtype', self.model_dtype)
        lat = self.lattice
        psi = MPS.from_product_state(lat.mps_sites(), p_state, bc=lat.bc_MPS, dtype=dtype)
        return psi

    def desired_bond_dimension(self, chi=None):
        """Initialize a trivial charge MPS with desired bond dimension.

        See :meth:`MPS.from_desired_bond_dimension` for details.

        Options
        -------
        .. cfg:configoptions :: InitialStateBuilder

            chi : int
                The desired bond dimension passed on to :meth:`MPS.from_desired_bond_dimension`.
        """
        if chi is None:
            chi = self.options['chi']
        dtype = self.options.get('dtype', self.model_dtype)
        lat = self.lattice
        psi = MPS.from_desired_bond_dimension(lat.mps_sites(), chi, bc=lat.bc_MPS, dtype=dtype)
        return psi


    def check_filling(self, p_state):
        """Ensure that the filling of the product state matches `check_filling` parameter.

        Options
        -------
        .. cfg:configoptions :: InitialStateBuilder

            check_filling : None | (int, int) or float
                The desired filling as float ``p/q``, or by a tuple ``(p, q)``.
                ``None`` (default) disables the check.
            full_empty : (str, str)
                Definition of which local states are "full" and "empty".
                For example you can use ``full_empty=('up', 'down')`` if you have spin sites.
        """
        check_filling = self.options.get("check_filling", None)
        if check_filling is None:
            return
        full, empty = self.options.get("full_empty", ('full', 'empty'))
        p_state = np.asarray(p_state, dtype=object)
        N_filled = np.sum(p_state == full)
        N_total = p_state.size
        try:
            p, q = check_filling
            check_filling = p / q
        except:
            p, q = int(round(check_filling * N_total)), N_total
        if abs(p - check_filling * N_total) > 1.e-13:
            raise ValueError(
                "check_filling={0:.5f} doesn't fit as integer in p_state.size = {1:d}".format(
                    check_filling, N_total))
        if N_filled * q != N_total * p:  # int-version of N_filled/N_total != p/q
            raise ValueError("unexpected filling {0:.5f} != check_filling = {1:.5f}".format(
                N_filled / N_total, check_filling))
        # done

    def fill_where(self):
        """Allow to specify a condition where sites should be filled.

        .. warning ::
            The `fill_where` string is parsed with the python function `eval`;
            this is unsafe if the variable comes from an untrusted source (e.g. the internet).

        Options
        -------
        .. cfg:configoptions :: InitialStateBuilder

            fill_where : str
                A string specifying the condition where to fill sites.
                See examples in :meth:`fill_where`.
            full_empty : (str, str)
                Definition of which local states are "full" and "empty".
                For example you can use ``full_empty=('up', 'down')`` if you have spin sites.

        Examples
        --------
        Possible variables for conditions are specified in :meth:`fill_where__get_variables`,
        for example `x_ind, y_ind, u_ind`.

        You can do arbitrary logical expressions. Example conditions:
        - ``"x_ind == 0"``
        - ``"AND(x_ind == 0, y_ind == 0)"``
        - ``"AND(x_ind == 0, IN(y_ind, [0, 2])"``
        - ``"WITHIN(x_ind, 0.25*Lx, 0.75*Lx )"`` # 0.25*Lx <= x <= 0.75&Lx
        """
        variables = self.fill_where__get_variables()
        shape = variables['x_ind'].shape
        condition = self.options["fill_where"]
        full, empty = self.options.get('full_empty', ('full', 'empty'))
        try:
            fill_array = eval(condition, variables)
        except:
            print("Error in InitialStateBuilder.fill_where condition")
            print(">>> condition:")
            print(condition)
            print(">>> available variables:")
            print(sorted(variables.keys()))
            raise  # re-throw the error, we just print useful debugging info
        p_state = np.where(fill_array, to_array([full], shape=shape, dtype=object),
                           to_array([empty], shape=shape, dtype=object))
        return self.lat_product_state(p_state)

    def fill_where__get_variables(self):
        """Define the variables which can be used in the condition of :meth:`fill_where`.

        Here, the following variables get defined.

        x_ind, y_ind, u_ind : int
            Lattice indices of the
        eps : float
            Cutoff ``1.e-12`` that can get used when it is necessary to compare floats
        np :
            Numpy module, allowing to use any function from numpy.
        AND, OR, XOR, NOT, ANY, ALL, CLOSE, EQUAL, IN, WITHIN
            Function aliases to allow logical combinations.
            Use for example as ``AND(x_ind == 0, IN(y_ind, [0, 2, 5]))``.
        """
        lattice = self.lattice
        if lattice.dim == 1:
            Lx, Lu = lattice.shape
            x, u = np.mgrid[0:Lx, 0:Lu]
            variables = {'x_ind': x, 'u_ind': u, 'Lx': Lx, 'L': Lx, 'Lu': Lu}
        elif lattice.dim == 2:
            Lx, Ly, Lu = lattice.shape
            x, y, u = np.mgrid[0:Lx, 0:Ly, 0:Lu]
            variables = {'x_ind': x, 'y_ind': y, 'u_ind': u, 'Lx': Lx, 'Ly': Ly, 'Lu': Lu}
        else:
            raise NotImplementedError("3D lattice not handled...")

        def any_(*cond):
            return np.any(cond, axis=0)

        def all_(*cond):
            return np.all(cond, axis=0)

        def close(var, value, *, eps=1.e-12):
            return np.abs(var - value) < eps

        def oneof(var, values, *, eps=1.e-12):
            if eps:
                return np.any([close(var, val, eps=eps) for val in values], axis=0)
            return np.any([var == val for val in values], axis=0)

        def within(var, lower, upper, *, eps=1.e-12):
            if eps:
                lower = lower - eps
                upper = upper + eps
            return np.logical_and(np.less_equal(lower, var), np.less_equal(var, upper))

        variables.update({
            'np': np,  # numpy
            'AND': np.logical_and,
            'OR': np.logical_or,
            'XOR': np.logical_xor,
            'NOT': np.logical_not,
            'ANY': any_,
            'ALL': all_,
            'CLOSE': close,
            'EQUAL': np.equal,
            'IN': oneof,
            'WITHIN': within,
            'eps': 1.e-12,
        })
        return variables

    def randomized(self):
        """Initialize a state with another method and then apply a RandomUnitaryEvolution.

        Options
        -------
        .. cfg:configoptions :: InitialStateBuilder

            randomized_from_method : str
                Selects another method to initialize the starting state to be randomized,
                e.g., ``'lat_product_state'`` for :meth:`lat_product_state`.
            randomize_params : dict-like
                Parameters given to the :class:`~tenpy.algorithms.tebd.RandomUnitaryEvolution`.
                In particular, you might want to set the `N_steps` and `trunc_params['chi_max']`.
                The default is
                ``{'N_steps': 10, 'trunc_params': {'chi_max': max(100, max(psi.chi))}}``.
            randomize_canonicalize : bool
                Whether to call :meth:`MPS.canonical_form` before returning the state.
        """
        method_name = self.options['randomized_from_method']
        method = getattr(self, method_name)
        psi = method()
        close_1 = self.options.get('randomize_close_1', False)
        canonicalize = self.options.get('randomize_canonicalize', not close_1)
        params = {'N_steps': 10, 'trunc_params': {'chi_max': max(psi.chi + [100])}}
        params = self.options.subconfig('randomize_params', params)
        psi.perturb(params, close_1=close_1, canonicalize=canonicalize)
        return psi


def build_initial_state(size, states, filling, mode='random', seed=None):
    """Build an "initial state" list.

    Uses two iterables ('states' and 'filling') to determine how to fill the
    state. The two lists should have the same length as every element in 'filling' gives the filling
    fraction for the corresponding state in 'states'.

    Example:
        size = 6, states = [0, 1, 2], filling = [1./3, 2./3, 0.]
        n_states = size * filling = [2, 4, 0]
        ==> Two sites will get state 0, 4 sites will get state 1, 0 sites will
        get state 2.

    .. todo ::
        Make more general: it should be possible to specify states as strings.

    Parameters
    ----------
    size : int
        length of state
    states : iterable
        Containing the possible local states
    filling : iterable
        Fraction of the total number of sites to get a certain state. If
        infinite fractions (e.g. 1/3) are needed, one should supply a
        fraction (1./3.)
    mode : str | None
        State filling pattern. Only 'random' is implemented
    seed : int | None
        Seed for random number generators

    Returns
    -------
    initial_state (list) : the initial state

    Raises
    ------
    ValueError
        If fractional fillings are incommensurate with system size.
    AssertionError
        If the total filling is not equal to 1, or the length of `filling`
        does not equal the length of `states`.
    """

    random.seed(seed)

    # Do some safety checks
    assert sum(filling) == 1
    assert len(states) == len(filling)

    # Get number of sites for each local state
    n_states = np.array(filling) * size
    for num in n_states:
        if ((num - round(num)) < 1e-12):
            num = int(round(num))
        if type(num) != int and not num.is_integer():
            raise ValueError("Cannot create model of length {} with filling {}".format(
                size, filling))

    # Randomly assign local states
    initial_state = [0] * size
    all_sites = list(range(size))  # To avoid having two types on same site.
    for state, fill in zip(states, filling):
        sites = random.sample(set(all_sites),
                              int(fill * size))  # pick fill*size sites to put state
        for site in sites:
            initial_state[site] = state
            all_sites.remove(site)

    return initial_state
